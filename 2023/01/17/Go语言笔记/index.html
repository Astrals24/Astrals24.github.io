<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>深入理解Go | Astrals</title><meta name="author" content="DSAD"><meta name="copyright" content="DSAD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="深入理解Go">
<meta property="og:url" content="http://example.com/2023/01/17/Go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Astrals">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/go%E5%90%89%E7%A5%A5%E7%89%A94.png">
<meta property="article:published_time" content="2023-01-16T16:00:00.000Z">
<meta property="article:modified_time" content="2022-07-16T16:00:00.000Z">
<meta property="article:author" content="DSAD">
<meta property="article:tag" content="Go语言">
<meta property="article:tag" content="原理">
<meta property="article:tag" content="读书记录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/go%E5%90%89%E7%A5%A5%E7%89%A94.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/17/Go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深入理解Go',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-17 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./../images/%E9%80%8F%E6%98%8E.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Astrals"><span class="site-name">Astrals</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">深入理解Go</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-16T16:00:00.000Z" title="发表于 2023-01-17 00:00:00">2023-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-16T16:00:00.000Z" title="更新于 2022-07-17 00:00:00">2022-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>102分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="深入理解Go"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="深入理解Go"><a href="#深入理解Go" class="headerlink" title="深入理解Go"></a>深入理解Go</h3><hr>
<h4 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h4><p>地址总线</p>
<p>64位 一次最小寻址 8B 机器字长 （bmap 8个k的原因？）</p>
<p>每次操作4byte 要32位数据总线</p>
<p>每次操作8byte 要64位数据总线	</p>
<p>64位机器 cpu一次并行操作数8byte</p>
<p><img src="/./../images/cpu%E5%B9%B6%E8%A1%8C.png" alt="image-20220921210745401"></p>
<p>数据类型的对齐边界 <strong>是取数据类型大小 与 平台最大对齐边界中较小的那一个</strong>。</p>
<p><img src="/./../images/%E5%AF%B9%E9%BD%90%E8%BE%B9%E7%95%8C.png" alt="image-20220921210558951"></p>
<p>对于结构体</p>
<p>每次会判断结构体中类型字节占用最大的 作为对齐边界</p>
<p>类型大小要是对齐边界的整数倍 不够需要扩充至整数倍</p>
<p>所以 map[int8]int64  若 k-v存储 由于内存对齐 会浪费7字节</p>
<p><img src="/./../images/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.png" alt="image-20220921205903895"></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的<strong>变量会直接在栈上初始化</strong>，</p>
<p>如果数组元素大于 4 个，变量就会在<strong>静态存储区初始化然后拷贝到栈上</strong>，这些转换后的代码才会继续进入[中间代</p>
<p>码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。</p>
<p>数组作为一种基本的数据类型，我们通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数，在 Go 语言中我们往往会使用如下所示的方式来表示数组类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">[<span class="number">200</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​	Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。</p>
<p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这也就是编译器对数组大小的推导，</p>
<blockquote>
<p>数组的长度是在编译时静态计算的，并且数组无法在运行时动态扩缩容量的。使用append报错</p>
</blockquote>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>在 Go 语言中，切片类型的声明方式与数组有一些相似，<strong>不过由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]<span class="type">int</span></span><br><span class="line">[]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Go</p>
<p>从切片的定义我们能推测出，切片在编译期间的生成的类型只会包含切片中的元素类型，即 <code>int</code> 或者 <code>interface&#123;&#125;</code> 等</p>
<p>编译期间的切片是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/types.Slice"><code>cmd/compile/internal/types.Slice</code></a> 类型的，但是在运行时切片可以由如下的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.SliceHeader"><code>reflect.SliceHeader</code></a> 结构体表示，其中:</p>
<ul>
<li><code>Data</code> 是指向数组的指针;</li>
<li><code>Len</code> 是当前切片的长度；</li>
<li><code>Cap</code> 是当前切片的容量，即 <code>Data</code> 数组的大小：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">	Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Data</code> 是一片连续的内存空间，这片内存空间可以用于存储切片中的全部元素，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>Go 语言中包含三种初始化切片的方式：</p>
<ol>
<li>通过下标的方式获得数组或者切片的一部分；</li>
<li>使用字面量初始化新的切片；</li>
<li>使用关键字 <code>make</code> 创建切片：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>:<span class="number">3</span>] or slice[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>





<p>1.下标访问</p>
<p>使用下标创建切片是最原始也最接近汇编语言的方式，它是所有方法中最为底层的一种，编译器会将 <code>arr[0:3]</code> 或者 <code>slice[0:3]</code> 等语句转换成 <code>OpSliceMake</code> 操作</p>
<p>需要注意的是使用下标初始化切片<strong>不会拷贝</strong>原数组或者原切片中的数据，它<strong>只会创建一个指向原数组的切片结构体</strong>，所以<strong>修改新切片的数据也会修改原切片</strong>。</p>
<p>2.字面量</p>
<p>当我们使用字面量 <code>[]int&#123;1, 2, 3&#125;</code> 创建新的切片时，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.slicelit"><code>cmd/compile/internal/gc.slicelit</code></a> 函数会在编译期间将它展开成如下所示的代码片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vstat [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">vstat[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">vstat[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">vstat[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> vauto *[<span class="number">3</span>]<span class="type">int</span> = <span class="built_in">new</span>([<span class="number">3</span>]<span class="type">int</span>)</span><br><span class="line">*vauto = vstat</span><br><span class="line">slice := vauto[:]</span><br></pre></td></tr></table></figure>

<ol>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>创建一个同样指向 <code>[3]int</code> 类型的数组指针；</li>
<li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li>
<li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li>
</ol>
<p>第 5 步中的 <code>[:]</code> 就是使用下标创建切片的方法，从这一点我们也能看出 <code>[:]</code> 操作是创建切片最底层的一种方法。</p>
<p>3.make关键字</p>
<p>如果使用字面量的方式创建切片，大部分的工作都会在编译期间完成。但是当我们使用 <code>make</code> 关键字创建切片时，<strong>很多工作都需要运行时的参与</strong>；调用方必须向 <code>make</code> 函数传入切片的大小以及可选的容量</p>
<p>根据下面2个条件检查</p>
<ol>
<li>切片的大小和容量是否足够小；</li>
<li>切片是否发生了逃逸，最终在堆上初始化</li>
</ol>
<p>当切片发生逃逸或者非常大时，运行时需要 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.makeslice"><code>runtime.makeslice</code></a> 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">4</span>]<span class="type">int</span></span><br><span class="line">n := arr[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>上述代码会初始化数组并通过下标 <code>[:3]</code> 得到数组对应的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组并将 <code>[:3]</code> 转换成上一节提到的 <code>OpSliceMake</code> 操作。</p>
<h5 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a><strong>追加和扩容</strong></h5><p>使用 <code>append</code> 关键字向切片中追加元素也是常见的切片操作，中间代码生成阶段的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.append"><code>cmd/compile/internal/gc.state.append</code></a> 方法会根据返回值是否会覆盖原变量，选择进入两种流程，如果 <code>append</code> 返回的新切片不需要赋值回原有的变量，就会进入如下的处理流程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append(slice, 1, 2, 3)</span></span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := slice</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> newlen &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">    ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> = growslice(slice, newlen)</span><br><span class="line">    newlen = <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">*(ptr+<span class="built_in">len</span>) = <span class="number">1</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = <span class="number">3</span></span><br><span class="line"><span class="keyword">return</span> makeslice(ptr, newlen, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>

<p>我们会先解构切片结构体获取它的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.growslice"><code>runtime.growslice</code></a> 对切片进行扩容并将新的元素依次加入切片。</p>
<p>如果使用 <code>slice = append(slice, 1, 2, 3)</code> 语句，那么 <code>append</code> 后的切片会覆盖原切片，这时 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.append"><code>cmd/compile/internal/gc.state.append</code></a> 方法会使用另一种方式展开关键字：</p>
<p>是否覆盖原变量的逻辑其实差不多，最大的区别在于得到的新切片是否会赋值回原变量。如果我们选择覆盖原有的变量，就不需要担心切片发生拷贝影响性能，因为 Go 语言编译器已经对这种常见的情况做出了优化。</p>
<p><img src="/./../images/golang-slice-append.png" alt="golang-slice-append"></p>
<p>到这里我们已经清楚了 Go 语言如何在切片容量足够时向切片中追加元素，不过仍然需要研究切片容量不足时的处理流程。当切片的容量不足时，我们会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.growslice"><code>runtime.growslice</code></a> 函数为切片扩容，<strong>扩容是为切片分配新的内存空间并拷贝原切片中元素的过程</strong>，我们先来看新切片的容量是如何确定的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">    <span class="comment">// 如果当前所需容量 （cap） 大于原先容量的两倍 （doublecap），则最终申请容量（newcap）为当前所需容量（cap）</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则 如果原切片长度（old.len）小于1024，则最终申请容量（newcap）等于原容量的两倍（doublecap）</span></span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则 最终申请容量（newcap，初始值等于 old.cap）每次增加 newcap/4，直到大于所需容量（cap）为止，然后，判断最终申请容量（newcap）是否溢出，如果溢出，最终申请容量（newcap）等于所需容量（cap）；</span></span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<p>上述代码片段仅会确定切片的大致容量，下面还需要根据切片中的元素大小对齐内存，当数组中元素所占的字节大小为 1、8 或者 2 的倍数时，运行时会使用如下所示的代码对齐内存：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">	lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">	newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap))</span><br><span class="line">	overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">	newcap = <span class="type">int</span>(capmem)</span><br><span class="line"><span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">	lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">	newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">	overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">	newcap = <span class="type">int</span>(capmem / sys.PtrSize)</span><br><span class="line"><span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.roundupsize"><code>runtime.roundupsize</code></a> 函数会将待申请的内存向上取整，取整时会使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.class_to_size"><code>runtime.class_to_size</code></a> 数组，使用该数组中的整数可以提高内存的分配效率并减少碎片，我们会在内存分配一节详细介绍该数组的作用：</p>
<p>在默认情况下，我们会将目标容量和元素大小相乘得到占用的内存。如果计算新容量时发生了内存溢出或者请求内存超过上限，就会直接崩溃退出程序，不过这里为了减少理解的成本，将相关的代码省略了。</p>
<p>如果切片中元素不是指针类型，那么会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.memclrNoHeapPointers"><code>runtime.memclrNoHeapPointers</code></a> <strong>将超出切片当前长度的位置清空并在最后使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 将原数组内存中的内容拷贝到新申请的内存中</strong>。这两个方法都是用目标机器上的汇编指令实现的，这里就不展开介绍了。</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.growslice"><code>runtime.growslice</code></a> 函数最终会返回一个新的切片，其中包含了新的数组指针、大小和容量，这个返回的三元组<strong>最终会覆盖原切片</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr []<span class="type">int64</span></span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>简单总结一下扩容的过程，当我们执行上述代码时，会触发 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.growslice"><code>runtime.growslice</code></a> 函数扩容 <code>arr</code> 切片并传入期望的新容量 5，这时期望分配的内存大小为 40 字节；不过因为切片中的元素大小等于 <code>sys.PtrSize</code>，所以运行时会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.roundupsize"><code>runtime.roundupsize</code></a> 向上取整内存的大小到 48 字节，所以新切片的容量为 48 &#x2F; 8 &#x3D; 6</p>
<blockquote>
<p>注 sys.PtrSize<code> 表示系统指针大小，在 32 位机器中，</code>sys.PtrSize &#x3D; 4<code>，64 位机器中，</code>sys.PtrSize &#x3D; 8</p>
</blockquote>
<img src="./../images/slice扩容机制.png" alt="img" style="zoom: 50%;" />



<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiangshihua/p/15771993.html">Golang 切片（slice）扩容机制源码剖析 - 天心PHP - 博客园 (cnblogs.com)</a></p>
<h5 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a><strong>拷贝</strong></h5><p>当使用<code>copy(a,b)</code>的形式对切片进行拷贝时，编译期间的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.copyany"><code>cmd/compile/internal/gc.copyany</code></a> 也会分两种情况进行处理拷贝操作，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line">    n = <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a.ptr != b.ptr &#123;</span><br><span class="line">    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 会负责拷贝内存。而如果拷贝是在运行时发生的，例如：<code>go copy(a, b)</code>，编译器会使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.slicecopy"><code>runtime.slicecopy</code></a> 替换运行期间调用的 <code>copy</code>.</p>
<p>无论是编译期间拷贝还是运行时拷贝，两种拷贝方式都会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 将整块内存的内容拷贝到目标的内存区域中：</p>
<p><img src="/./../images/2019-02-20-golang-slice-copy.png" alt="golang-slice-copy"></p>
<p>相比于依次拷贝元素，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 能够提供更好的性能。需要注意的是，整块拷贝内存仍然会占用非常多的资源，<strong>在大切片上执行拷贝操作时一定要注意对性能的影响</strong>。</p>
<blockquote>
<p><strong>注意</strong></p>
</blockquote>
<p>切片的很多功能都是由运行时实现的，无论是初始化切片，还是对切片进行追加或扩容都需要运行时的支持，需要注意的是在遇到<strong>大切片扩容或者复制时可能会发生大规模的内存拷贝</strong>，一定要减少类似操作避免影响程序的性能。</p>
<h4 id="map哈希表"><a href="#map哈希表" class="headerlink" title="map哈希表"></a>map哈希表</h4><p>[go map数据结构和源码详解 - Jo_ZSM - 博客园 ](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/JoZSM/p/11784037.html#:~:text=go%E7%9A%84map%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%98%AFhash%E8%A1%A8%EF%BC%88C%2B%2B%E7%9A%84map%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%80%8CC%2B%2B">https://www.cnblogs.com/JoZSM/p/11784037.html#:~:text=go的map底层实现方式是hash表（C%2B%2B的map是红黑树实现，而C%2B%2B</a> 11新增的unordered_map则与go的map类似，都是hash实现）。,go map的数据被置入一个由桶组成的有序数组中，每个桶最多可以存放8个key%2Fvalue对。)</p>
<p>Go 语言运行时同时使用了多个数据结构组合表示哈希表，其中 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.hmap"><code>runtime.hmap</code></a> 是最核心的结构体，我们先来了解一下该结构体的内部字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	B         <span class="type">uint8</span></span><br><span class="line">	noverflow <span class="type">uint16</span></span><br><span class="line">	hash0     <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	nevacuate  <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	overflow    *[]*bmap</span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line">	nextOverflow *bmap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a bucket for a Go map</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>  <span class="comment">//8位，占一字节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>count</code> 表示当前哈希表中的元素数量；</li>
<li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，<strong>但是因为哈希表中桶的数量都 2 的倍数？？？？</strong>，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>；</li>
<li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；</li>
<li><code>oldbuckets</code> 是哈希在扩容时用于保存之前 <code>buckets</code> 的字段，它的大小是当前 <code>buckets</code> 的一半；</li>
</ol>
<p><img src="/./../images/hmap-and-buckets.png" alt="hmap-and-buckets"></p>
<p>如上图所示哈希表 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.hmap"><code>runtime.hmap</code></a> 的桶是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.bmap"><code>runtime.bmap</code></a>。每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.bmap"><code>runtime.bmap</code></a> 都能存储 8 个键值对，当哈希表中存储的数据过多，单个桶已经装满时就会使用 <code>extra.nextOverflow</code> 中桶存储溢出的数据。</p>
<p>上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上图中<strong>黄色的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.bmap"><code>runtime.bmap</code></a></strong> 就是正常桶，<strong>绿色的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.bmap"><code>runtime.bmap</code></a></strong> 是溢出桶</p>
<p>桶的结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.bmap"><code>runtime.bmap</code></a> 在 Go 语言源代码中的定义只包含一个简单的 <code>tophash</code> 字段，<code>tophash</code> 存储了键的哈希的高 8 位，<strong>通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能？？？？？</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<hr>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>1.字面量</p>
<p>目前的现代编程语言基本都支持使用字面量的方式初始化哈希，一般都会使用 <code>key: value</code> 的语法来表示键值对，Go 语言中也不例外：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;3&quot;</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="string">&quot;5&quot;</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要在初始化哈希时声明键值对的类型，这种使用字面量初始化的方式最终都会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.maplit"><code>cmd/compile/internal/gc.maplit</code></a> 初始化，我们来分析一下该函数初始化哈希的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *Node, m *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	a := nod(OMAKE, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">	a.Esc = n.Esc</span><br><span class="line">	a.List.Set2(typenod(n.Type), nodintconst(<span class="type">int64</span>(n.List.Len())))</span><br><span class="line">	litas(m, a, init)</span><br><span class="line"></span><br><span class="line">	entries := n.List.Slice()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(entries) &gt; <span class="number">25</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build list of var[c] = expr.</span></span><br><span class="line">	<span class="comment">// Use temporaries so that mapassign1 can have addressable key, elem.</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当哈希表中的元素数量少于或者等于 25 个时</strong>，编译器会将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>这种初始化的方式与的<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/">数组</a>和<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">切片</a>几乎完全相同，由此看来集合类型的初始化在 Go 语言中有着相同的处理逻辑。</p>
<p>一旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的 for 循环加入哈希：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">vstatk := []<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, ... ， <span class="string">&quot;26&quot;</span>&#125;</span><br><span class="line">vstatv := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ... , <span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstak); i++ &#123;</span><br><span class="line">    hash[vstatk[i]] = vstatv[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里展开的两个切片 <code>vstatk</code> 和 <code>vstatv</code> 还会被编辑器继续展开，具体的展开方式可以阅读上一节了解<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">切片的初始化</a>，不过无论使用哪种方法，<strong>使用字面量初始化的过程都会使用 Go 语言中的关键字 <code>make</code> 来创建新的哈希并通过最原始的 <code>[]</code> 语法向哈希追加元素。</strong></p>
<p>2.运行时</p>
<p>当创建的哈希被分配到栈上并且其容量小于 <code>BUCKETSIZE = 8</code> 时，Go 语言在编译阶段会使用如下方式快速初始化哈希，这也是编译器对小容量的哈希做的优化：</p>
<p>除此之外都时调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.makemap"><code>runtime.makemap</code></a>进行创建</p>
<p>这个函数会按照下面的步骤执行：</p>
<ol>
<li>计算哈希占用的内存是否溢出或者超出能分配的最大值；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.fastrand"><code>runtime.fastrand</code></a> 获取一个随机的哈希种子；</li>
<li>根据传入的 <code>hint</code> 计算出需要的最小需要的桶的数量；</li>
<li>使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.makeBucketArray"><code>runtime.makeBucketArray</code></a> 创建用于保存桶的数组；</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.makeBucketArray"><code>runtime.makeBucketArray</code></a> 会根据传入的 <code>B</code> 计算出的需要创建的桶数量并在<strong>内存中分配一片连续的空间用于存储数据</strong>：</p>
<ul>
<li>当桶的数量小于 2^4 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</li>
<li>当桶的数量多于 2^4 时，会额外创建 2^(B-4)个溢出桶；</li>
</ul>
<p>在正常情况下，正常桶和溢出桶在内存中的存储空间是连续的，只是被 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.hmap"><code>runtime.hmap</code></a> 中的不同字段引用，当溢出桶数量较多时会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.newobject"><code>runtime.newobject</code></a> 创建新的溢出桶。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make(map[k]v, hint), hint即预分配大小</span></span><br><span class="line"><span class="comment">// 不传hint时，如用new创建个预设容量为0的map时，makemap只初始化hmap结构，不分配hash数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">    <span class="comment">//所以创建map时一次内存分配既分配了用户预期大小的hash数组，又追加了一定量的预留的溢出桶，还做了内存对齐，一举多得</span></span><br></pre></td></tr></table></figure>







<h5 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h5><p>哈希表作为一种数据结构，我们肯定要分析它的常见操作，首先就是读写操作的原理。哈希表的访问一般都是通过下标或者遍历进行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_ = hash[key]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> hash &#123;</span><br><span class="line">    <span class="comment">// k, v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式虽然都能读取哈希表的数据，但是使用的函数和底层原理完全不同。<strong>前者需要知道哈希的键并且一次只能获取单个键对应的值</strong>，而<strong>后者可以遍历哈希中的全部键值对</strong>，访问数据时也不需要预先知道哈希的键。</p>
<p>数据结构的写一般指的都是增加、删除和修改，<strong>增加和修改字段都使用索引和赋值语句</strong>，而删除字典中的数据需要使用关键字 <code>delete</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash[key] = value</span><br><span class="line">hash[key] = newValue</span><br><span class="line"><span class="built_in">delete</span>(hash, key)</span><br></pre></td></tr></table></figure>





<h5 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v     := hash[key] <span class="comment">// =&gt; v     := *mapaccess1(maptype, hash, &amp;key)</span></span><br><span class="line">v, ok := hash[key] <span class="comment">// =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)</span></span><br></pre></td></tr></table></figure>

<p>赋值语句左侧接受参数的个数会决定使用的运行时方法：</p>
<ul>
<li>当接受一个参数时，会使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mapaccess1"><code>runtime.mapaccess1</code></a>，该函数仅会返回一个指向目标值的指针；</li>
<li>当接受两个参数时，会使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mapaccess2"><code>runtime.mapaccess2</code></a>，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的 <code>bool</code> 值：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mapaccess1"><code>runtime.mapaccess1</code></a> 会先通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.bucketMask"><code>runtime.bucketMask</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.add"><code>runtime.add</code></a> 拿到该键值对所在的桶序号和哈希高位的 8 位数字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line">				<span class="keyword">return</span> v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>bucketloop</code> 循环中，哈希会依次遍历正常桶和溢出桶中的数据，它会先比较哈希的高 8 位和桶中存储的 <code>tophash</code>，后比较传入的和桶中的值以加速数据的读写。用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高 8 位，这种设计能够减少同一个桶中有大量相等 <code>tophash</code> 的概率影响性能。</p>
<p><img src="/./../images/hashmap-mapaccess.png" alt="hashmap-mapaccess"></p>
<blockquote>
<p>这种设计能够减少同一个桶中有大量相等 <code>tophash</code> 的概率影响性能</p>
<p>注：因为bmap结构中会先访问高8位的tophash 并和其之前计算得到的hashcode ，</p>
</blockquote>
<p>如上图所示，每一个桶都是一整片的内存空间，<strong>当发现桶中的 <code>tophash</code> 与传入键的 <code>tophash</code> 匹配之后</strong>，我们会通过指针和偏移量获取哈希中<strong>存储的键 <code>keys[0]</code> 并与 <code>key</code> 比较</strong>，如果两者相同就会获取目标值的指针 <code>values[0]</code> 并返回。</p>
<p>另一个同样用于访问哈希表中数据的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mapaccess2"><code>runtime.mapaccess2</code></a> 只是在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mapaccess1"><code>runtime.mapaccess1</code></a> 的基础上多返回了一个标识键值对是否存在的 <code>bool</code> 值：</p>
<h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>我们简单总结一下哈希表扩容的设计和原理，哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，扩容过程不是原子的，而是通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.growWork"><code>runtime.growWork</code></a> 增量触发的，在扩容期间访问哈希表时会使用旧桶，向哈希表写入数据时会触发旧桶元素的分流。除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了 <code>sameSizeGrow</code> 这一机制，在出现较多溢出桶时会整理哈希的内存减少空间的占用。（<strong>等量扩容 创建等量的新通 此时溢出桶教多 但是没有触发增量扩容，表示可能由大量被删除的键值，此时空间排列不紧凑，等量扩容让空间更加紧凑，减少溢出桶的使用。</strong>）</p>
<p>1.负载因子大于6.5 触发增量扩容 翻倍</p>
<p>2.使用过多溢出桶 触发等量扩容 （常规桶数目 &lt; 2^15  溢出桶超过常规桶）</p>
<blockquote>
<p>根据触发的条件不同扩容的方式分成两种，如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容 <code>sameSizeGrow</code>，<code>sameSizeGrow</code> 是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:4">4</a>。<a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/9980b70cb460f27907a003674ab1b9bea24a847c">runtime: limit the number of map overflow buckets</a> 引入了 <code>sameSizeGrow</code> 通过复用已有的哈希扩容机制解决该问题，一旦哈希中出现了过多的溢出桶，它会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:5">5</a>。</p>
</blockquote>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>如果想要删除哈希中的元素，就需要使用 Go 语言中的 <code>delete</code> 关键字，这个关键字的唯一作用就是将某一个键对应的元素从哈希表中删除，无论是该键对应的值是否存在，这个内建的函数都不会返回任何的结果。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Go 语言使用拉链法来解决哈希碰撞的问题实现了哈希表，它的访问、写入和删除等操作都在编译期间转换成了运行时的函数或者方法。哈希在每一个桶中存储键对应哈希的前 8 位，当对哈希进行操作时，这些 <code>tophash</code> 就成为可以帮助哈希快速遍历桶中元素的缓存。</p>
<p>哈希表的每个桶都只能存储 8 个键值对，一旦当前哈希的某个桶超出 8 个，新的键值对就会存储到哈希的溢出桶中。随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容<strong>（负载因子大于6.5    数据量&#x2F;桶数量）</strong>，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。</p>
<p>说说map实现原理：</p>
<p>1.数组+链表形式存储  通过拉链法解决哈希碰撞。底层结构是hamp，B表示hash持有的桶数量 是2的倍数  桶结构是bmap，每个bmap都能存储8个k-v 有tophash字段比较高8位，overflow是溢出桶地址，当数据存储过多，就会使用溢出桶来存储数据。</p>
<p>2.每个桶数量要是2的倍数 因为计算hash 选桶 分散均匀</p>
<p>map底层创建时，会初始化一个hmap结构体，同时分配一个足够大的内存空间A。其中A的前段用于hash数组，A的后段预留给溢出的桶。于是hmap.buckets指向hash数组，即A的首地址；hmap.extra.nextOverflow初始时指向内存A中的后段，即hash数组结尾的下一个桶，也即第1个预留的溢出桶。所以当hash冲突需要使用到新的溢出桶时，会优先使用上述预留的溢出桶，hmap.extra.nextOverflow依次往后偏移直到用完所有的溢出桶，才有可能会申请新的溢出桶空间。</p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/28214">Golang Map实现（一） - Go语言中文网 - Golang中文社区 (studygolang.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://golang2.eddycjy.com/">前言 | Go 语言编程之旅 (eddycjy.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44807796/article/details/113400429#:~:text=Go%E8%AF%AD%E8%A8%80%E7%9A%84map%E9%BB%98%E8%AE%A4%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90" title="count %2F (2^B">go专家编程系列（4）常见数据结构 map_EINTR的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/star_of_science/article/details/121802354">(60条消息) Go map底层原理（哈希表）_王致列的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://eddycjy.com/posts/go/map/2019-03-05-map-access/">深入理解 Go map：初始化和访问元素 (eddycjy.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JoZSM/p/11784037.html#:~:text=go,map%E7%9A%84hash%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%E6%98%AF%E6%A1%B6%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%A1%B6%E6%9C%80%E5%A4%9A%E5%AD%988%E4%B8%AA%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E8%B6%85%E4%BA%86%EF%BC%8C%E5%88%99%E4%BC%9A%E9%93%BE%E6%8E%A5%E5%88%B0%E9%A2%9D%E5%A4%96%E7%9A%84%E6%BA%A2%E5%87%BA%E6%A1%B6%E3%80%82">go map数据结构和源码详解 - Jo_ZSM - 博客园 (cnblogs.com)</a></p>
<h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><p>1.为什么哈希表中桶的数量都 2 的倍数？</p>
<p>2.为什么比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能？</p>
<p>3.使用溢出桶怎么减少扩容次数？</p>
<p>4.若hash冲突了 tophash 怎么存储？</p>
<p>5.为什么tophash是8位 而不是其他位数？（也就是k-v为什么是8个）</p>
<p>6.为什么key-value 分开存储？</p>
<p>7.低8位和高8位 key hash</p>
<blockquote>
<p>1.为什么哈希表中桶的数量都 2 的倍数？</p>
</blockquote>
<p>从键值的存储流程开始，当一个键值对来了 自然需要存储到一个桶中，然后将Key()通过Hash()处理一下得到hash值。现在要利用这个hash值从m个桶中选择一个,桶的编号[0,m-1]</p>
<p><strong>取模法</strong></p>
<p>hash%m</p>
<p><strong>与运算法</strong></p>
<p>hash &amp; (m-1)   <strong>增加运算速度</strong></p>
<p><strong>m是2的倍数时候 才等价 可以 均匀散列</strong>   </p>
<p>如果m &#x3D;  2 二进制是10  则  m-1 二进制是 1</p>
<p>​	   m &#x3D; 4  二进制是100  则m-1 二进制是 11	</p>
<p>​	   m &#x3D; 8  二进制是1000 则m-1 二进制是 111</p>
<p>这样2^n -1 得出的结果除最高位必定是1111</p>
<p>这样和hashcode计算时就仅仅由hashcode决定值 而不会形成”缺口”</p>
<p>如果不是2的倍数 例如 m &#x3D;9  则 二进制是  10001   无论hashcode是多少 计算得到的值永远在第一个桶和最后一个桶 其余桶永远不会由数据。</p>
<p>所以想要使用与运算法就要限制桶的个数 m 必须是2 的整数次幂，这样 m 的二进制表示一定只有一位为1，(m-1) 就是</p>
<p>除了最高为其他均为 1 ，避免计算hash 只会分配到固定的几个桶 导致一些桶绝对不会被选中的情况</p>
<p>如果之后有其他键值对也选择了同一个桶，就是发生了哈希冲突，解决方案一般是 开放地址法 和 拉链法</p>
<p><strong>2倍这个数字贯穿了map的很多部分</strong></p>
<blockquote>
<p>2.为什么比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能？</p>
</blockquote>
<p>解答：当tophash对应的K&#x2F;V被使用时，存的是key的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%93%88%E5%B8%8C&spm=1001.2101.3001.7020">哈希</a>值的高8位；当tophash对应的K&#x2F;V未被使用时，存的是K&#x2F;V对应位置的状态。</p>
<p><img src="/./../images/tophash.png" alt="[外链图片转存失败(img-VCPzgZ2R-1564057589001)(./1560938034341.png)]"></p>
<p>下面是map源码中对tophash状态值的定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emptyRest      = <span class="number">0</span> </span><br><span class="line">emptyOne       = <span class="number">1</span> </span><br><span class="line">evacuatedX     = <span class="number">2</span> </span><br><span class="line">evacuatedY     = <span class="number">3</span></span><br><span class="line">evacuatedEmpty = <span class="number">4</span></span><br><span class="line">minTopHash     = <span class="number">5</span> </span><br></pre></td></tr></table></figure>

<p>当tophash[i] &lt; 5时，表示存的是状态；<br>当tophash[i] &gt;&#x3D; 5时，表示存的是哈希值；</p>
<p>那么问题来了，如果key的哈希值高8位小于minTopHash时，这时候怎么区分是存的状态还是哈希值？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">	top := <span class="type">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">	<span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">		top += minTopHash</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>直接看上面源码，第3-5行可以知道，当计算的哈希值小于minTopHash时，会直接在原有哈希值基础上加上minTopHash，确保哈希值一定大于minTopHash。</p>
<blockquote>
<p>5</p>
<ol>
<li><strong>为啥bucket 一次要存8个kv，而不是一个kv放一个bucket，然后链地址法做处理就OK了</strong> 据我分析，有几点原因: a， 一次分配8个kv的空间，可以减少内存的分配频次; b，减少了overflow指针的内存占用，比如说8个kv，采用一个一个存储的话，需要8 * 8B （64位机） &#x3D; 64B的数据存下一个的地址，而采用go实现的这种方式，只需要 8B + 8B (bmap的大小） &#x3D; 16B 的数据就可以了。</li>
<li><strong>为啥需要用tophash</strong> 一般的hash 实现逻辑是直接和key比较，如果比较成功，这找到相应key的数据。但是这里用到了tophash，好处是可以减少key的比较成本（毕竟key 不一定都是整数形式存在的）</li>
<li><strong>为啥是8个</strong> 8 * 8B &#x3D; 64B 整好是64位机的一个最小寻址空间，不过可以通过修改源码自定义吧。</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li></li>
</ol>
<p>keys和values为分开存储的，因为key和value可能是不同类型，比如map[int64]int8</p>
<p>此时kv&#x2F;kv&#x2F;kv 形式由于内存对其将浪费7字节，  kkkvvv 就可以节省空间</p>
</blockquote>
<blockquote>
<p>8</p>
<ul>
<li>根据低八位计算得到 bucket 的内存地址，并判断是否正在扩容，若正在扩容中则先迁移再接着处理</li>
<li>计算并得到 bucket 的 bmap 指针地址，计算 key hash 高八位用于查找 Key</li>
</ul>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="拼接问题"><a href="#拼接问题" class="headerlink" title="拼接问题"></a>拼接问题</h5><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.addstr"><code>cmd/compile/internal/gc.addstr</code></a> 能帮助我们在编译期间选择合适的函数对字符串进行拼接，该函数会根据带拼接的字符串数量选择不同的逻辑：</p>
<ul>
<li>如果小于或者等于 5 个，那么会调用 <code>concatstring&#123;2,3,4,5&#125;</code> 等一系列函数；</li>
<li>如果超过 5 个，那么会选择 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.concatstrings"><code>runtime.concatstrings</code></a> 传入一个数组切片；</li>
</ul>
<p>其实无论使用 <code>concatstring&#123;2,3,4,5&#125;</code> 中的哪一个，最终都会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.concatstrings"><code>runtime.concatstrings</code></a>，它会先对遍历传入的切片参数，再过滤空字符串并计算拼接后字符串的长度。</p>
<p>字符串在 Go 语言中是不可变类型，占用内存大小是固定的，当使用 <code>+</code> 拼接 2 个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和。拼接第三个字符串时，再开辟一段新空间，新空间大小是三个字符串大小之和，以此类推。假设一个字符串大小为 10 byte，拼接 1w 次，需要申请的内存大小为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 + 2 * 10 + 3 * 10 + ... + 10000 * 10 byte = 500 MB </span><br></pre></td></tr></table></figure>

<p>而 <code>strings.Builder</code>，<code>bytes.Buffer</code>，包括切片 <code>[]byte</code> 的内存是以倍数申请的。例如，初始大小为 0，当第一次写入大小为 10 byte 的字符串时，则会申请大小为 16 byte 的内存（恰好大于 10 byte 的 2 的指数），第二次写入 10 byte 时，内存不够，则申请 32 byte 的内存，第三次写入内存足够，则不申请新的，以此类推。在实际过程中，超过一定大小，比如 2048 byte 后，申请策略上会有些许调整</p>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>[]byte转string</p>
<p>从字节数组到字符串的转换需要使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.slicebytetostring"><code>runtime.slicebytetostring</code></a> 函数，例如：<code>string(bytes)</code></p>
<p>他会根据传入的缓冲区大小决定是否需要为新字符串分配一片内存空间，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stringStructOf"><code>runtime.stringStructOf</code></a> 会将传入的字符串指针转换成 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stringStruct"><code>runtime.stringStruct</code></a> 结构体指针，然后设置结构体持有的字符串指针 <code>str</code> 和长度 <code>len</code>，最后通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 将原 <code>[]byte</code> 中的字节全部复制到新的内存空间中。</p>
<p>字符串转[]byte</p>
<p>当我们想要将字符串转换成 <code>[]byte</code> 类型时，需要使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stringtoslicebyte"><code>runtime.stringtoslicebyte</code></a> 函数，该函数的实现非常容易理解：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">		*buf = tmpBuf&#123;&#125;</span><br><span class="line">		b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b = rawbyteslice(<span class="built_in">len</span>(s))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(b, s)</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数会根据是否传入缓冲区做出不同的处理：</p>
<ul>
<li>当传入缓冲区时，它会使用传入的缓冲区存储 <code>[]byte</code>；</li>
<li>当没有传入缓冲区时，运行时会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.rawbyteslice"><code>runtime.rawbyteslice</code></a> 创建新的字节切片并将字符串中的内容拷贝过去；</li>
</ul>
<p>字符串和 <code>[]byte</code> 中的内容虽然一样，但是字符串的内容是只读的，我们不能通过下标或者其他形式改变其中的数据，而 <code>[]byte</code> 中的内容是可以读写的。不过无论从哪种类型转换到另一种都需要拷贝数据，而内存拷贝的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</p>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p><strong>C语言</strong></p>
<p>我们可以将本节的发现和分析简单总结成 — 当我们在 x86_64 的机器上使用 C 语言中调用函数时，参数都是通过寄存器和栈传递的，其中：</p>
<ul>
<li>六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；</li>
<li>六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中；</li>
</ul>
<p>而函数的返回值是通过 <strong>eax 寄存器</strong>进行传递的，<strong>由于只使用一个寄存器存储返回值</strong>，所以 C 语言的函数不能同时返回多个值。</p>
<p><strong>Go语言</strong></p>
<p>通过分析 Go 语言编译后的汇编指令，我们发现 Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。</p>
<p><strong>对比</strong></p>
<p>C 语言和 Go 语言在设计函数的调用惯例时选择了不同的实现。C 语言同时使用寄存器和栈传递参数，<strong>使用 eax 寄存器传递返回值</strong>；而 <strong>Go 语言使用栈传递参数和返回值</strong>。我们可以对比一下这两种设计的优点和缺点：</p>
<ul>
<li>C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；<ul>
<li>CPU 访问栈的开销比访问寄存器高几十倍<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#fn:3">3</a>；</li>
<li>需要单独处理函数参数过多的情况；</li>
</ul>
</li>
<li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；<ul>
<li>不需要考虑超过寄存器数量的参数应该如何传递；</li>
<li>不需要考虑不同架构上的寄存器差异；</li>
<li>函数入参和出参的内存空间需要在栈上进行分配；</li>
</ul>
</li>
</ul>
<p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p>
<p><strong>参数传递</strong></p>
<p>所以能得出如下结论：<strong>Go 语言的整型和数组类型都是值传递的</strong>，也就是在调用函数时会对内容进行拷贝。需要注意的是如果当前数组的大小非常的大，这种传值的方式会对<strong>性能造成比较大的影响</strong>。</p>
<p><strong>结构体和指针</strong></p>
<p>接下来我们继续分析 Go 语言另外两种常见类型 — 结构体和指针。下面这段代码中定义了一个结构体 <code>MyStruct</code> 以及接受两个参数的 <code>myFunction</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	i <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(a MyStruct, b *MyStruct)</span></span> &#123;</span><br><span class="line">	a.i = <span class="number">31</span></span><br><span class="line">	b.i = <span class="number">41</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;in my_function - a=(%d, %p) b=(%v, %p)\n&quot;</span>, a, &amp;a, b, &amp;b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := MyStruct&#123;i: <span class="number">30</span>&#125;</span><br><span class="line">	b := &amp;MyStruct&#123;i: <span class="number">40</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;before calling - a=(%d, %p) b=(%v, %p)\n&quot;</span>, a, &amp;a, b, &amp;b)</span><br><span class="line">	myFunction(a, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;after calling  - a=(%d, %p) b=(%v, %p)\n&quot;</span>, a, &amp;a, b, &amp;b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">before calling - a=(&#123;<span class="number">30</span>&#125;, <span class="number">0xc000018178</span>) b=(&amp;&#123;<span class="number">40</span>&#125;, <span class="number">0xc00000c028</span>)</span><br><span class="line">in my_function - a=(&#123;<span class="number">31</span>&#125;, <span class="number">0xc000018198</span>) b=(&amp;&#123;<span class="number">41</span>&#125;, <span class="number">0xc00000c038</span>)</span><br><span class="line">after calling  - a=(&#123;<span class="number">30</span>&#125;, <span class="number">0xc000018178</span>) b=(&amp;&#123;<span class="number">41</span>&#125;, <span class="number">0xc00000c028</span>)</span><br></pre></td></tr></table></figure>

<p>Go</p>
<p>从上述运行的结果我们可以得出如下结论：</p>
<ul>
<li>传递结构体时：会拷贝结构体中的全部内容；</li>
<li>传递结构体指针时：会拷贝结构体指针；</li>
</ul>
<p>修改结构体指针是改变了指针指向的结构体，<code>b.i</code> 可以被理解成 <code>(*b).i</code>，也就是我们先获取指针 <code>b</code> 背后的结构体，再修改结构体的成员变量</p>
<p>将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，所以 <strong>Go 语言中传指针也是传值</strong>。</p>
<p>当我们验证了 Go 语言中大多数常见的数据结构之后，其实能够推测出 Go 语言在传递参数时使用了传值的方式，</p>
<p>接收方收到参数时会对这些参数进行复制；了解到这一点之后，在<strong>传递数组或者内存占用非常大的结构体时</strong>，我们</p>
<p>应该<strong>尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能</strong>。</p>
<p>Go 通过栈传递函数的参数和返回值，在调用函数之前会在栈上为返回值分配合适的内存空间，随后将入参从右到左按顺序压栈并拷贝参数，返回值会被存储到调用方预留好的栈空间上，我们可以简单总结出以下几条规则：</p>
<ol>
<li>通过堆栈传递参数，入栈的顺序是从右到左，而参数的计算是从左到右；</li>
<li>函数返回值通过堆栈传递并由调用者预先分配内存空间；</li>
<li>调用函数时都是传值，接收方会对入参进行复制再计算；</li>
</ol>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>interface{} 类型是一种特殊的类型  它可以装下其余类型任何值，它不属于其余任何一种类型。</p>
<p>interface表示一种类型，可以接收任何实现了interface当中规定的方法的类型的值。当我们定义inteface{}的时候，其实是定义了<strong>空的interface</strong>，相当于不需要实现任何方法的空interface，所以任何类型都可以接收，这也就是它成为万能类型的原因。</p>
<p>一个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类型需要实现 <code>error</code> 接口，那么它只需要实现 <code>Error() string</code> 方法，下面的 <code>RPCError</code> 结构体就是 <code>error</code> 接口的一个实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code    <span class="type">int64</span></span><br><span class="line">	Message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *RPCError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, code=%d&quot;</span>, e.Message, e.Code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用&amp;对结构体进只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段行取地址操作相当于对该结构体类型进行了一次new实例化操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rpcErr <span class="type">error</span> = NewRPCError(<span class="number">400</span>, <span class="string">&quot;unknown err&quot;</span>) <span class="comment">// typecheck1</span></span><br><span class="line">	err := AsErr(rpcErr) <span class="comment">// typecheck2  返回了一个被实现了的 error类型的接口 </span></span><br><span class="line">    <span class="built_in">println</span>(err.<span class="type">error</span>())</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRPCError</span><span class="params">(code <span class="type">int64</span>, msg <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RPCError&#123; <span class="comment">// typecheck3</span></span><br><span class="line">		Code:    code,</span><br><span class="line">		Message: msg,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsErr</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Go 语言中<strong>接口的实现都是隐式的</strong></p>
<p>Go 语言实现接口的方式与 Java 完全不同：</p>
<ul>
<li>在 Java 中：实现接口需要显式地声明接口并实现所有方法；</li>
<li>在 Go 中：实现接口的所有方法就隐式地实现了接口；</li>
</ul>
<p>我们使用上述 <code>RPCError</code> 结构体时并不关心它实现了哪些接口，Go 语言只会在<strong>传递参数、返回参数以及变量赋值</strong>时才会对<strong>某个类型是否实现接口</strong>进行检查，</p>
<p><strong>接口的底层数据结构</strong></p>
<p>​	Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：</p>
<ul>
<li>使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体表示包含方法的接口</li>
<li>使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.eface"><code>runtime.eface</code></a> 结构体表示不包含任何方法的 <code>interface&#123;&#125;</code> 类型；</li>
</ul>
<p>动态派发（Dynamic dispatch）是在运行期间选择具体多态操作（方法或者函数）执行的过程，它是面向对象语言中的常见特性<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:6">6</a>。Go 语言虽然不是严格意义上的面向对象语言，但是接口的引入为它带来了动态派发这一特性，调用接口类型的方法时，如果编译期间不能确认接口的类型，Go 语言会在运行期间决定具体调用该方法的哪个实现。</p>
<p>在如下所示的代码中，<code>main</code> 函数调用了两次 <code>Quack</code> 方法：</p>
<ol>
<li>第一次以 <code>Duck</code> <strong>接口类型的身份调用</strong>，调用时需要经过运行时的动态派发；</li>
<li>第二次以 <code>*Cat</code> <strong>具体类型的身份调用</strong>，编译期就会确定调用的函数：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">	c.(*Cat).Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">直接调用</th>
<th align="center">动态派发</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">指针</td>
<td align="center">~3.03ns</td>
<td>~3.58ns</td>
</tr>
<tr>
<td align="center">结构体</td>
<td align="center">~3.09ns</td>
<td>~6.98ns</td>
</tr>
</tbody></table>
<p><em>表 4-2 直接调用和动态派发的性能对比</em></p>
<p>从上述表格我们可以看到使用结构体实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，<strong>这也提醒我们应当尽量避免使用结构体类型实现接口</strong>。</p>
<p>使用结构体带来的巨大性能差异不只是接口带来的问题，带来性能问题主要<strong>因为 Go 语言在函数调用时是传值的</strong>，<strong>动态派发的过程只是放大了参数拷贝带来的影响</strong>。</p>
<p>[<a target="_blank" rel="noopener" href="https://xargin.com/go-and-interface/">译]Go 和 interface 探究 (xargin.com)</a></p>
<hr>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1720559074833243171&wfr=spider&for=pc">深入浅出Go语言：反射机制及应用 (baidu.com)</a></p>
<p>运行时反射是程序在运行期间检查其自身结构的一种方式</p>
<p>反射作为一种元编程方式可以减少重复代码</p>
<p>Go 语言反射的三大法则<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#fn:3">3</a>，其中包括：</p>
<ol>
<li>从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li>
<li>从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li>
<li>要修改反射对象，其值必须可设置；</li>
</ol>
<p><strong>第一法则</strong></p>
<p>我们可以通过以下例子简单介绍它们的作用，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.TypeOf"><code>reflect.TypeOf</code></a> 获取了变量 <code>author</code> 的类型，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.ValueOf"><code>reflect.ValueOf</code></a> 获取了变量的值 <code>draven</code>。如果我们知道了一个变量的类型和值，那么就意味着我们知道了这个变量的全部信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	author := <span class="string">&quot;draven&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;TypeOf author:&quot;</span>, reflect.TypeOf(author))</span><br><span class="line">	fmt.Println(<span class="string">&quot;ValueOf author:&quot;</span>, reflect.ValueOf(author))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">TypeOf author: <span class="type">string</span></span><br><span class="line">ValueOf author: draven</span><br></pre></td></tr></table></figure>



<p><strong>第二法则</strong></p>
<p>反射的第二法则是我们可以从反射对象可以获取 <code>interface&#123;&#125;</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<a target="_blank" rel="noopener" href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.Interface"><code>reflect.Value.Interface</code></a> 就能完成这项工作：</p>
<p><strong>第三法则</strong></p>
<p>由于 Go 语言的函数调用都是传值的，所以我<strong>们得到的反射对象跟最开始的变量没有任何关系</strong>，那么直接修改反射对象无法改变原始变量，程序为了防止错误就会崩溃。</p>
<p>想要修改原变量只能使用如下的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	v := reflect.ValueOf(&amp;i)</span><br><span class="line">	v.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run reflect.<span class="keyword">go</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<ol>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.ValueOf"><code>reflect.ValueOf</code></a> 获取变量指针；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.Elem"><code>reflect.Value.Elem</code></a> 获取指针指向的变量；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.SetInt"><code>reflect.Value.SetInt</code></a> 更新变量的值：</li>
</ol>
<p>由于 Go 语言的函数调用都是值传递的，所以我们只能只能用迂回的方式改变原变量：先获取指针对应的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value"><code>reflect.Value</code></a>，再通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.Elem"><code>reflect.Value.Elem</code></a> 方法得到可以被设置的变量，我们可以通过下面的代码理解这个过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	v := &amp;i</span><br><span class="line">	*v = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不能直接操作 <code>i</code> 变量修改其持有的值，我们就只能获取 <code>i</code> 变量所在地址并使用 <code>*v</code> 修改所在地址中存储的整数。</p>
<p>空interface{}结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>更新变量</strong></p>
<p>当我们想要更新 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value"><code>reflect.Value</code></a> 时，就需要调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.Set"><code>reflect.Value.Set</code></a> 更新反射对象</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.Set"><code>reflect.Value.Set</code></a> 会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.assignTo"><code>reflect.Value.assignTo</code></a> 并返回一个新的反射对象，这个返回的反射对象指针会</p>
<p>直接覆盖原反射变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> assignTo(context <span class="type">string</span>, dst *rtype, target unsafe.Pointer) Value &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> directlyAssignable(dst, v.typ):</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span> Value&#123;dst, v.ptr, fl&#125;</span><br><span class="line">	<span class="keyword">case</span> implements(dst, v.typ):</span><br><span class="line">		<span class="keyword">if</span> v.Kind() == Interface &amp;&amp; v.IsNil() &#123;</span><br><span class="line">			<span class="keyword">return</span> Value&#123;dst, <span class="literal">nil</span>, flag(Interface)&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		x := valueInterface(v, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> dst.NumMethod() == <span class="number">0</span> &#123;</span><br><span class="line">			*(*<span class="keyword">interface</span>&#123;&#125;)(target) = x</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ifaceE2I(dst, x, target)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;dst, target, flagIndir | flag(Interface)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">panic</span>(context + <span class="string">&quot;: value of type &quot;</span> + v.typ.String() + <span class="string">&quot; is not assignable to type &quot;</span> + dst.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.assignTo"><code>reflect.Value.assignTo</code></a> 会根据当前和被设置的反射对象类型创建一个新的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value"><code>reflect.Value</code></a> 结构体：</p>
<ul>
<li>如果两个反射对象的类型是可以被直接替换，就会直接返回目标反射对象；</li>
<li>如果当前反射对象是接口并且目标对象实现了接口，就会把目标对象简单包装成接口值；</li>
</ul>
<p>在变量更新的过程中，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.assignTo"><code>reflect.Value.assignTo</code></a> 返回的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value"><code>reflect.Value</code></a> 中的指针会覆盖当前反射对象中的指针实现变量的更新。</p>
<p><strong>接口检查</strong></p>
<p><a target="_blank" rel="noopener" href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 包还为我们提供了 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.rtype.Implements"><code>reflect.rtype.Implements</code></a> 方法可以用于判断某些类型是否遵循特定的接口。在 Go 语言中获取结构体的反射类型 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Type"><code>reflect.Type</code></a> 还是比较容易的，但是想要获得接口类型需要通过以下方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.TypeOf((*&lt;<span class="keyword">interface</span>&gt;)(<span class="literal">nil</span>)).Elem()</span><br></pre></td></tr></table></figure>

<p>我们通过一个例子在介绍如何判断一个类型是否实现了某个接口。假设我们需要判断如下代码中的 <code>CustomError</code> 是否实现了 Go 语言标准库中的 <code>error</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	typeOfError := reflect.TypeOf((*<span class="type">error</span>)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">	customErrorPtr := reflect.TypeOf(&amp;CustomError&#123;&#125;)</span><br><span class="line">	customError := reflect.TypeOf(CustomError&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(customErrorPtr.Implements(typeOfError)) <span class="comment">// #=&gt; true</span></span><br><span class="line">	fmt.Println(customError.Implements(typeOfError)) <span class="comment">// #=&gt; false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go</p>
<p>上述代码的运行结果正如我们在<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/">接口</a>一节中介绍的：</p>
<ul>
<li><code>CustomError</code> 类型并没有实现 <code>error</code> 接口；</li>
<li><code>*CustomError</code> 指针类型实现了 <code>error</code> 接口；</li>
</ul>
<p><strong>判断原理</strong></p>
<p>1.首先<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.rtype.Implements"><code>reflect.rtype.Implements</code></a> 会检查传入的类型是不是接口,如果不是接口会直接中止程序</p>
<p>2.判断接口中包含的方法，若不包含方法就返回true,否则遍历，</p>
<p><strong>动态方法调用</strong></p>
<p>作为一门静态语言，如果我们想要通过 <a target="_blank" rel="noopener" href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 包利用反射在运行期间执行方法不是一件容易的事情，下面的十几行代码就使用反射来执行 <code>Add(0, 1)</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(Add)</span><br><span class="line">	<span class="keyword">if</span> v.Kind() != reflect.Func &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t := v.Type()</span><br><span class="line">	argv := <span class="built_in">make</span>([]reflect.Value, t.NumIn())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> argv &#123;</span><br><span class="line">		<span class="keyword">if</span> t.In(i).Kind() != reflect.Int &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		argv[i] = reflect.ValueOf(i)</span><br><span class="line">	&#125;</span><br><span class="line">	result := v.Call(argv)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(result) != <span class="number">1</span> || result[<span class="number">0</span>].Kind() != reflect.Int &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(result[<span class="number">0</span>].Int()) <span class="comment">// #=&gt; 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.ValueOf"><code>reflect.ValueOf</code></a> 获取函数 <code>Add</code> 对应的反射对象；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.rtype.NumIn"><code>reflect.rtype.NumIn</code></a> 获取函数的入参个数；</li>
<li>多次调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.ValueOf"><code>reflect.ValueOf</code></a> 函数逐一设置 <code>argv</code> 数组中的各个参数；</li>
<li>调用反射对象 <code>Add</code> 的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.Value.Call"><code>reflect.Value.Call</code></a> 方法并传入参数列表；</li>
<li>获取返回值数组、验证数组的长度以及类型并打印其中的数据；</li>
</ol>
<p>使用反射来调用方法非常复杂，<strong>原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成</strong>，但这也是在静态语言中使用动态特性需要付出的成本。</p>
<p>reflect.Value.Call 在编译期间链接到 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.reflectcall"><code>reflect.reflectcall</code></a> 这个用汇编实现的函数 比较复杂</p>
<p>Go 语言的 <a target="_blank" rel="noopener" href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 包为我们提供了多种能力，包括如何使用反射来动态修改变量、判断类型是否实现了某些接口以及动态调用方法等功能</p>
<hr>
<h4 id="for-range"><a href="#for-range" class="headerlink" title="for-range"></a>for-range</h4><p>与简单的经典循环相比，范围循环在 Go 语言中更常见、实现也更复杂。这种循环同时使用 <code>for</code> 和 <code>range</code> 两个关键字，<strong>编译器会在编译期间将所有 for-range 循环变成经典循环</strong>。从编译器的视角来看，就是将 <code>ORANGE</code> 类型的节点转换成 <code>OFOR</code> 节点</p>
<h5 id="循环永动机"><a href="#循环永动机" class="headerlink" title="循环永动机"></a><strong>循环永动机</strong></h5><p>对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新变量 <code>ha</code>，在赋值的过程中就发生了拷贝，而我们又通过 <code>len</code> 关键字预先获取了切片的长度，所以在循环中追加新的元素也不会改变循环执行的次数，这也就解释了循环永动机一节提到的现象。</p>
<p>而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 <code>v2</code> 变量存储切片中的元素，<strong>循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，赋值时也会触发拷贝</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;arr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(*v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在循环中获取返回变量的地址都完全相同，所以会发生神奇的指针一节中的现象。因此当我们想要访问数组中元素所在的地址时，不应该直接获取 range 返回的变量地址 <code>&amp;v2</code>，而应该使用 <code>&amp;a[index]</code> 这种形式。</p>
<h5 id="for-range陷阱"><a href="#for-range陷阱" class="headerlink" title="for range陷阱"></a><strong>for range陷阱</strong></h5><p>而遇到这种同时遍<strong>历索引和元素</strong>的 range 循环时，Go 语言会额外创建一个新的 <code>v2</code> 变量存储切片中的元素，<strong>循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，赋值时也会触发拷贝</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;arr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(*v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在<strong>循环中获取返回变量的地址都完全相同（每次取得是V2变量得地址 正确应该取arr[i]得地址</strong>），所以会发生神奇的指针一节中的现象。因此当我们想要访问数组中元素所在的地址时，不应该直接获取 range 返回的变量地址 <code>&amp;v2</code>，而应该使用 <code>&amp;a[index]</code> 这种形式。</p>
<p><strong>通道</strong> </p>
<p>使用 range 遍历 Channel 也是比较常见的做法，一个形如 <code>for v := range ch &#123;&#125;</code> 的语句最终会被转换成如下的格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1, hb := &lt;-ha</span><br><span class="line"><span class="keyword">for</span> ; hb != <span class="literal">false</span>; hv1, hb = &lt;-ha &#123;</span><br><span class="line">    v1 := hv1</span><br><span class="line">    hv1 = <span class="literal">nil</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码可能与编译器生成的稍微有一些出入，但是结构和效果是完全相同的。该循环会使用 <code>&lt;-ch</code> 从管道中取出等待处理的值，这个操作会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.chanrecv2"><code>runtime.chanrecv2</code></a> 并阻塞当前的协程，当 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.chanrecv2"><code>runtime.chanrecv2</code></a> 返回时会根据布尔值 <code>hb</code> 判断当前的值是否存在：</p>
<ul>
<li>如果不存在当前值，意味着当前的管道已经被关闭；</li>
<li>如果存在当前值，会为 <code>v1</code> 赋值并清除 <code>hv1</code> 变量中的数据，然后重新陷入阻塞等待新数据；</li>
</ul>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>例子</p>
<p><code>select</code> 是与 <code>switch</code> 相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式<strong>必须都是 Channel 的收发操作</strong>。下面的代码就展示了一个包含 Channel 收发操作的 <code>select</code> 结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述控制结构会等待 <code>c &lt;- x</code> 或者 <code>&lt;-quit</code> 两个表达式中任意一个返回。无论哪一个表达式返回都会立刻执行 <code>case</code> 中的代码，当 <code>select</code> 中的两个 <code>case</code> 同时被触发时，会随机执行其中的一个。</p>
<p><strong>现象</strong></p>
<p>当我们在 Go 语言中使用 <code>select</code> 控制结构时，会遇到两个有趣的现象：</p>
<ol>
<li><code>select</code> 能在 Channel 上进行非阻塞的收发操作；</li>
<li><code>select</code> 在遇到多个 Channel 同时响应时，会随机执行一种情况；（避免按顺序的饥饿问题发生）</li>
</ol>
<p>我们来深入了解具体场景并分析这两个现象背后的设计原理。</p>
<p><img src="/./../images/golang-oselect-and-ocases.png" alt="golang-oselect-and-ocases"></p>
<p>编译器在中间代码生成期间会根据 <code>select</code> 中 <code>case</code> 的不同对控制语句进行优化，这一过程都发生在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.walkselectcases"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数中，我们在这里会分四种情况介绍处理的过程和结果：</p>
<ol>
<li><code>select</code> 不存在任何的 <code>case</code>；</li>
<li><code>select</code> 只存在一个 <code>case</code>；</li>
<li><code>select</code> 存在两个 <code>case</code>，其中一个 <code>case</code> 是 <code>default</code>；</li>
<li><code>select</code> 存在多个 <code>case</code>；</li>
</ol>
<p>上述四种情况不仅会涉及编译器的重写和优化，还会涉及 Go 语言的运行时机制，我们会从编译期间和运行时两个角度分析上述情况。</p>
<ol>
<li><p>直接阻塞</p>
<p>select 不存在任何case时直接阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p>
</li>
</ol>
<p>​	2.单一管道 </p>
<p>如果当前的 <code>select</code> 条件只包含一个 <code>case</code>，那么编译器会将 <code>select</code> 改写成 <code>if</code> 条件语句。下面对比了改写前后的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改写前</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok &lt;-ch: <span class="comment">// case ch &lt;- v</span></span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写后</span></span><br><span class="line"><span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line">v, ok := &lt;-ch <span class="comment">// case ch &lt;- v</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.walkselectcases"><code>cmd/compile/internal/gc.walkselectcases</code></a> 在处理单操作 <code>select</code> 语句时，会根据 Channel 的收发情况生成不同的语句。当 <code>case</code> 中的 Channel 是空指针时，会直接挂起当前 Goroutine 并陷入永久休眠。</p>
<p>我们简单总结一下 <code>select</code> 结构的执行过程与实现原理，首先在编译期间，Go 语言会对 <code>select</code> 语句进行优化，它会根据 <code>select</code> 中 <code>case</code> 的不同选择不同的优化路径：</p>
<ol>
<li><p>空的 <code>select</code> 语句会被转换成调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.block"><code>runtime.block</code></a> 直接挂起当前 Goroutine；</p>
</li>
<li><p>如果<code>select</code>语句中只包含一个<code>case</code>编译器会将其转换成<code>if ch == nil &#123; block &#125;; n;</code></p>
<p> 表达式；</p>
<ul>
<li>首先判断操作的 Channel 是不是空的；</li>
<li>然后执行 <code>case</code> 结构中的内容；</li>
</ul>
</li>
<li><p>如果 <code>select</code> 语句中只包含两个 <code>case</code> 并且其中一个是 <code>default</code>，那么会使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.selectnbrecv"><code>runtime.selectnbrecv</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.selectnbsend"><code>runtime.selectnbsend</code></a> 非阻塞地执行收发操作；</p>
</li>
<li><p>在默认情况下会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.selectgo"><code>runtime.selectgo</code></a> 获取执行 <code>case</code> 的索引，并通过多个 <code>if</code> 语句执行对应 <code>case</code> 中的代码；</p>
</li>
</ol>
<p>在编译器已经对 <code>select</code> 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.selectgo"><code>runtime.selectgo</code></a> 函数，该函数会按照以下的流程执行：</p>
<ol>
<li><p>随机生成一个遍历的轮询顺序 <code>pollOrder</code> 并根据 Channel 地址生成锁定顺序 <code>lockOrder</code>；</p>
</li>
<li><p>根据<code>pollOrder</code>遍历所有的<code>case</code></p>
<p>查看是否有可以立刻处理的 Channel；</p>
<ol>
<li>如果存在，直接获取 <code>case</code> 对应的索引并返回；</li>
<li>如果不存在，创建 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.gopark"><code>runtime.gopark</code></a> 挂起当前 Goroutine 等待调度器的唤醒；</li>
</ol>
</li>
<li><p>当调度器唤醒当前 Goroutine 时，会再次按照 <code>lockOrder</code> 遍历所有的 <code>case</code>，从中查找需要被处理的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 对应的索引；</p>
</li>
</ol>
<p><code>select</code> 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。</p>
<h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>我们在 Go 语言中使用 <code>defer</code> 时会遇到两个常见问题，这里会介绍具体的场景并分析这两个现象背后的设计原理：</p>
<ul>
<li><code>defer</code> 关键字的调用时机以及多次调用 <code>defer</code> 时执行顺序是如何确定的；</li>
<li><code>defer</code> 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果；</li>
</ul>
<p>1.作用域</p>
<p>利用defer倒序输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>运行上述代码会倒序执行传入 <code>defer</code> 关键字的所有表达式，因为最后一次调用 <code>defer</code> 时传入了 <code>fmt.Println(4)</code>，所以这段代码会优先打印 4。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer runs&quot;</span>)</span><br><span class="line">        fmt.Println(<span class="string">&quot;block ends&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;main ends&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">block ends</span><br><span class="line">main ends</span><br><span class="line"><span class="keyword">defer</span> runs</span><br></pre></td></tr></table></figure>

<p>从上述代码的输出我们会发现，<code>defer</code> 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用。</p>
<p>2.参数计算</p>
<p>[深入 Go 语言 defer 实现原理 - 腾讯云开发者社区-腾讯云 (tencent.com)](<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1820164#:~:text=defer">https://cloud.tencent.com/developer/article/1820164#:~:text=defer</a> 声明时会先计算确定参数的值 func a() { i %3A%3D 0,在这个例子中，变量 i 在 defer 被调用的时候就已经确定了，而不是在 defer 执行的时候，所以上面的语句输出的是 0。)</p>
<p>Go 语言中所有的函数调用都是传值的，虽然 <code>defer</code> 是关键字，但是也继承了这个特性。假设我们想要计算 <code>main</code> 函数运行的时间，可能会写出以下的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startedAt := time.Now()</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(time.Since(startedAt))</span><br><span class="line">	</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">0</span>s</span><br></pre></td></tr></table></figure>

<p>然而上述代码的运行结果并不符合我们的预期，这个现象背后的原因是什么呢？经过分析，我们会发现调用 <code>defer</code> 关键字会立刻拷贝函数中引用的外部参数，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出 0s。</p>
<p>想要解决这个问题的方法非常简单，我们只需要向 <code>defer</code> 关键字传入匿名函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startedAt := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(time.Since(startedAt)) &#125;()</span><br><span class="line">	</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">1</span>s</span><br></pre></td></tr></table></figure>

<p>虽然调用 <code>defer</code> 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 <code>time.Since(startedAt)</code> 会在 <code>main</code> 函数返回前调用并打印出符合预期的结果。</p>
<p><strong>defer 声明时会先计算确定参数的值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    defer fmt.<span class="title class_">Println</span>(i) <span class="comment">// 0</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<strong>变量 i 在 <code>defer</code>被调用的时候就已经确定了，而不是在 <code>defer</code>执行的时候</strong>，所以上面的语句输出的是 0。</p>
<p><strong>defer 可以修改有名返回值函数的返回值</strong></p>
<p>如同官方所说：</p>
<blockquote>
<p>For instance, if the deferred function is a function literal and the surrounding function has named result parameters that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. </p>
</blockquote>
<p>上面所说的是，如果一个被<code>defer</code>调用的函数是一个 function literal，也就是说是闭包或者匿名函数，并且调用 <code>defer</code>的函数时一个有名返回值(named result parameters)的函数，那么 defer 可以直接访问有名返回值并进行修改的。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f returns 42</span></span><br><span class="line">func <span class="title function_">f</span>() (result int) &#123;</span><br><span class="line">	defer <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">		result *= <span class="number">7</span>  <span class="comment">//可直接修改返回值</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是需要注意的是，只能修改有名返回值(named result parameters)函数，匿名返回值函数是无法修改的，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f returns 100</span></span><br><span class="line">func <span class="title function_">f</span>() int &#123;</span><br><span class="line">	i := <span class="number">100</span></span><br><span class="line">	defer <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">		i++</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为匿名返回值函数是在<code>return</code>执行时被声明，因此在<code>defer</code>语句中只能访问有名返回值函数，而不能直接访问匿名返回值函数。</p>
<p><strong>derfer与return的执行顺序</strong></p>
<p>Golang语言中函数的return不是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020">原子操作</a>，在底层是分为两步来执行</p>
<p>1.返回值 赋值保存	如果返回值为匿名格式，那么将用一个临时变量保存该返回值</p>
<p>2.真正的RET返回</p>
<p>如果函数中存在defer 那么那么 执行顺序时机是在第一步和第二步之间即</p>
<p>1.返回值 赋值保存	如果返回值为匿名格式，那么将用一个临时变量保存该返回值</p>
<p>2.defer执行</p>
<p>3.真正的RET返回</p>
<p><strong>我们在本节前面提到的两个现象在这里也可以解释清楚了：</strong></p>
<ul>
<li><p>后调用的<code>defer</code></p>
<p>函数会先执行：</p>
<ul>
<li>后调用的 <code>defer</code> 函数会被追加到 Goroutine <code>_defer</code> 链表的最前面；</li>
<li>运行 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 时是从前到后依次执行；</li>
</ul>
</li>
<li><p>函数的参数会被预先计算；</p>
<ul>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；</li>
</ul>
</li>
</ul>
<h4 id="panic-与-recover"><a href="#panic-与-recover" class="headerlink" title="panic 与 recover"></a>panic 与 recover</h4><p>Go 语言中两个经常成对出现的两个关键字 — <code>panic</code> 和 <code>recover</code>。这两个关键字与上一节提到的 <code>defer</code> 有紧密的联系，它们都是 Go 语言中的内置函数，也提供了互补的功能。</p>
<ul>
<li><code>panic</code> 能够改变程序的控制流，调用 <code>panic</code> 后会<strong>立刻停止执行当前函数的剩余代码</strong>，并在当前 Goroutine 中递归<strong>执行调用方的 <code>defer</code>；</strong></li>
<li><code>recover</code> 可以中止 <code>panic</code> 造成的程序崩溃。<strong>它是一个只能在 <code>defer</code> 中发挥作用的函数</strong>，在其他作用域中调用不会发挥作用；</li>
</ul>
<p><strong>现象</strong></p>
<p>我们先通过几个例子了解一下使用 <code>panic</code> 和 <code>recover</code> 关键字时遇到的现象，部分现象也与上一节分析的 <code>defer</code> 关键字有关：</p>
<ul>
<li><code>panic</code> 只会触发当前 Goroutine 的 <code>defer</code>；</li>
<li><code>recover</code> 只有在 <code>defer</code> 中调用才会生效；</li>
<li><code>panic</code> 允许在 <code>defer</code> 中嵌套多次调用；</li>
</ul>
<p><strong>1.跨协程失效</strong></p>
<p>首先要介绍的现象是 <code>panic</code> 只会触发当前 Goroutine 的延迟函数调用，我们可以通过如下所示的代码了解该现象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;in main&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;in goroutine&quot;</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">in goroutine</span><br><span class="line"><span class="built_in">panic</span>:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当我们运行这段代码时会发现 <code>main</code> 函数中的 <code>defer</code> 语句并没有执行，执行的只有当前 Goroutine 中的 <code>defer</code>。</p>
<p>前面我们曾经介绍过 <code>defer</code> 关键字对应的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 会将延迟调用函数与调用方所在 Goroutine 进行关联。<strong>所以当程序发生崩溃时只会调用当前 Goroutine 的延迟调用函数也是非常合理的</strong></p>
<p><img src="/./../images/golang-panic-and-defers.png" alt="golang-panic-and-defers"></p>
<p><strong>2.失效的崩溃恢复</strong></p>
<p>初学 Go 语言的读者可能会写出下面的代码，在主程序中调用 <code>recover</code> 试图中止程序的崩溃，但是从运行的结果中我们也能看出，下面的程序没有正常退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;in main&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;unknown err&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">in main</span><br><span class="line"><span class="built_in">panic</span>: unknown err</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">	...</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>仔细分析一下这个过程就能理解这种现象背后的原因，<code>recover</code> 只有在发生 <code>panic</code> 之后调用才会生效。然而在上面的控制流中，<code>recover</code> 是在 <code>panic</code> 之前调用的，并不满足生效的条件，所以我们需要在 <code>defer</code> 中使用 <code>recover</code> 关键字。</p>
<h4 id="make和new"><a href="#make和new" class="headerlink" title="make和new"></a>make和new</h4><p>当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — <code>make</code> 和 <code>new</code>。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:1">1</a>，但是它们两者能够初始化的变量却有较大的不同。</p>
<ul>
<li><code>make</code> 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:2">2</a>；</li>
<li><code>new</code> 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:3">3</a>；</li>
</ul>
<p>我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="number">10</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>slice</code> 是一个包含 <code>data</code>、<code>cap</code> 和 <code>len</code> 的结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.SliceHeader"><code>reflect.SliceHeader</code></a>；</li>
<li><code>hash</code> 是一个指向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.hmap"><code>runtime.hmap</code></a> 结构体的指针；</li>
<li><code>ch</code> 是一个指向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.hchan"><code>runtime.hchan</code></a> 结构体的指针；</li>
</ol>
<p>相比与复杂的 <code>make</code> 关键字，<code>new</code> 的功能就简单多了，<strong>它只能接收类型作为参数然后返回一个指向该类型的指针</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="type">int</span></span><br><span class="line">i := &amp;v</span><br></pre></td></tr></table></figure>

<p>上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 <code>int</code> 零值的指针。</p>
<h4 id="上下文Context"><a href="#上下文Context" class="headerlink" title="上下文Context"></a>上下文Context</h4><p>上下文 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计</p>
<p>设计原理</p>
<p><strong>在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的最大作用。</strong>Go 服务的每一个请求都是通过单独的 Goroutine 处理的<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#fn:2">2</a>，HTTP&#x2F;RPC 请求的处理器会启动新的 Goroutine 访问数据库和其他服务。</p>
<p>如下图所示，我们可能会创建多个 Goroutine 来处理一次请求，而 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的作用是在不同 Goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。</p>
<p><img src="/./../images/golang-context-usage.png" alt="golang-context-usage"></p>
<p>每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 都会从最顶层的 Goroutine 一层一层传递到最下层。<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 可以在上层 Goroutine 执行出现错误时，将信号及时同步给下层。</p>
<p>当最上层的 Goroutine 因为某些原因执行失败时，下层的 Goroutine 由于没有接收到这个信号所以会继续工作；但是当我们正确地使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 时，就可以在下层及时停掉无用的工作以减少额外资源的消耗</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 是 Go 语言在 1.7 版本中引入标准库的接口<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#fn:1">1</a>，该接口定义了四个需要实现的方法，其中包括：</p>
<ol>
<li><code>Deadline</code> — 返回 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 被取消的时间，也就是完成工作的截止日期；</li>
<li><code>Done</code> — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 <code>Done</code> 方法会返回同一个 Channel；</li>
<li><code>Err</code>— 返回<code>context.Context</code>结束的原因，它只会在<code>Done</code>方法对应的 Channel 关闭时返回非空的值；<ol>
<li>如果 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 被取消，会返回 <code>Canceled</code> 错误；</li>
<li>如果 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 超时，会返回 <code>DeadlineExceeded</code> 错误；</li>
</ol>
</li>
<li><code>Value</code> — 从 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 中获取键对应的值，对于同一个上下文来说，多次调用 <code>Value</code> 并传入相同的 <code>Key</code> 会返回相同的结果，该方法可以用来传递请求特定的数据；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	Err() <span class="type">error</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中提供的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Background"><code>context.Background</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.TODO"><code>context.TODO</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithDeadline"><code>context.WithDeadline</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithValue"><code>context.WithValue</code></a> 函数会返回实现该接口的私有结构体，我们会在后面详细介绍它们的工作原理。</p>
<p><strong>Background  与 TODO</strong></p>
<p> context 包提供了 Background 方法和 TODO 方法，用来返回一个emptyContext</p>
<p>我们可以用这个 空的 Context 作为 goroutine 的root 节点（如果把整个 goroutine 的关系看作 树状）</p>
<p><strong>例子</strong></p>
<p>我们可以通过一个代码片段了解 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 是如何对信号进行同步的。在这段代码中，我们创建了一个过期时间为 1s 的上下文，并向上下文传入 <code>handle</code> 函数，该方法会使用 500ms 的时间处理传入的请求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> handle(ctx, <span class="number">500</span>*time.Millisecond)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">&quot;main&quot;</span>, ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(ctx context.Context, duration time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">&quot;handle&quot;</span>, ctx.Err())</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">		fmt.Println(<span class="string">&quot;process request with&quot;</span>, duration)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为过期时间大于处理时间，所以我们有足够的时间处理该请求，运行上述代码会打印出下面的内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run context.<span class="keyword">go</span></span><br><span class="line">process request with <span class="number">500</span>ms</span><br><span class="line">main context deadline exceeded</span><br></pre></td></tr></table></figure>

<p><code>handle</code> 函数没有进入超时的 <code>select</code> 分支，但是 <code>main</code> 函数的 <code>select</code> 却会等待 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 超时并打印出 <code>main context deadline exceeded</code>。</p>
<p>如果我们将处理请求时间增加至 1500ms，整个程序都会因为上下文的过期而被中止，：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run context.<span class="keyword">go</span></span><br><span class="line">main context deadline exceeded</span><br><span class="line">handle context deadline exceeded</span><br></pre></td></tr></table></figure>

<p>相信这两个例子能够帮助各位读者理解 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的使用方法和设计原理 — <strong>多个 Goroutine 同时订阅 <code>ctx.Done()</code> 管道中的消息****，一旦接收到取消信号就立刻停止当前正在执行的工作。</strong></p>
<p><strong>用法</strong></p>
<p>withvalue</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tang_yu_mac/article/details/122249280">https://blog.csdn.net/tang_yu_mac/article/details/122249280</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/google/uuid&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    helloWorldHandler := http.HandlerFunc(HelloWorld)</span><br><span class="line">    http.Handle(<span class="string">&quot;/welcome&quot;</span>, inejctMsgID(helloWorldHandler))</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 本地启动8080服务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HelloWorld hellow world handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloWorld</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    msgID := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">// 获取msgID上下文</span></span><br><span class="line">    <span class="keyword">if</span> m := r.Context().Value(<span class="string">&quot;msgId&quot;</span>); m != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> value, ok := m.(<span class="type">string</span>); ok &#123;</span><br><span class="line">            msgID = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w.Header().Add(<span class="string">&quot;msgId&quot;</span>, msgID)</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, world&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inejctMsgID</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        msgID := uuid.New().String()</span><br><span class="line">        <span class="comment">// 基于r.Context创建WithValue 并赋值msgId</span></span><br><span class="line">        ctx := context.WithValue(r.Context(), <span class="string">&quot;msgId&quot;</span>, msgID)</span><br><span class="line">        req := r.WithContext(ctx) <span class="comment">// 传递给HelloWorld</span></span><br><span class="line">        next.ServeHTTP(w, req)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013276277/article/details/108923912">golang之context使用_云原生手记的博客-CSDN博客_withdeadline withtimeout区别</a></p>
<h4 id="同步原语与锁"><a href="#同步原语与锁" class="headerlink" title="同步原语与锁"></a>同步原语与锁</h4><h5 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a><strong>Mutex</strong></h5><p>Go 语言的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a> 由两个字段 <code>state</code> 和 <code>sema</code> 组成。其中 <code>state</code> 表示当前互斥锁的状态，而 <code>sema</code> 是用于控制锁状态的信号量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line">	sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</p>
<p>我们已经从多个方面分析了互斥锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a> 的实现原理，这里我们从加锁和解锁两个方面总结注意事项。</p>
<p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p>
<ul>
<li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li>
<li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code>runtime.sync_runtime_SemacquireMutex</code></a> 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li>
</ul>
<p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p>
<ul>
<li>当互斥锁已经被解锁时，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Unlock"><code>sync.Mutex.Unlock</code></a> 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.runtime_Semrelease"><code>sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li>
</ul>
<h5 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h5><p>读写互斥锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex"><code>sync.RWMutex</code></a> 是细粒度的互斥锁，它不限制资源的并发读，但是读写、写写操作无法并行执行。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">读</th>
<th align="center">写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">写</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
</tbody></table>
<p><strong>表 6-1 RWMutex 的读写并发</strong></p>
<p>常见服务的资源读写比例会非常高，因为大多数的读请求之间不会相互影响，所以我们可以分离读写操作，以此来提高服务的性能。</p>
<p>读写锁是针对于读写操作的互斥锁。它与普通的互斥锁最大的不同就是，它可以分别针对读操作和写操作进行锁定和解锁操作。读写锁遵循的访问控制规则与互斥锁有所不同。在读写锁管辖的范围内，它允许任意个读操作的同时进行。但是，在同一时刻，它只允许有一个写操作在进行。并且，在某一个写操作被进行的过程中，读操作的进行也是不被允许的。也就是说，读写锁控制下的多个写操作之间都是互斥的，并且写操作与读操作之间也都是互斥的。但是，多个读操作之间却不存在互斥关系。</p>
<p>换句话说:</p>
<ol>
<li>同时只能有一个 goroutine 能够获得写锁定。</li>
<li>同时可以有任意多个 gorouinte 获得读锁定。</li>
<li>同时只能存在写锁定或读锁定（读和写互斥）。</li>
</ol>
<h5 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h5><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">    &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 将原本顺序执行的代码在多个 Goroutine 中并发执行，加快程序处理的速度。</p>
<p>WaitGroup 用于等待一组 goroutine 结束，用法很简单。它有三个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (wg *WaitGroup) Add(delta int)</span><br><span class="line">func (wg *WaitGroup) Done()</span><br><span class="line">func (wg *WaitGroup) Wait()</span><br></pre></td></tr></table></figure>

<ul>
<li>Add 用来添加 goroutine 的个数</li>
<li>Done 执行一次数量减 1</li>
<li>Wait 用来等待结束</li>
</ul>
<p>通过对 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 的分析和研究，我们能够得出以下结论：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 必须在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Done"><code>sync.WaitGroup.Done</code></a> 只是对 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 Goroutine；</li>
<li>可以同时有多个 Goroutine 等待当前 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li>
</ul>
<p><strong>Once</strong></p>
<p>Go 语言标准库中 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 可以保证在 Go 程序运行期间的某段代码只会执行一次。在运行如下所示的代码时，我们会看到如下所示的运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := &amp;sync.Once&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;only once&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">only once</span><br></pre></td></tr></table></figure>



<p>作为用于保证函数执行次数的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 结构体，它使用互斥锁和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic"><code>sync/atomic</code></a> 包提供的方法实现了某个函数在程序运行期间只能执行一次的语义。在使用该结构体时，我们也需要注意以下的问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.Do"><code>sync.Once.Do</code></a> 方法中传入的函数只会被执行一次，哪怕函数中发生了 <code>panic</code>；</li>
<li>两次调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.Do"><code>sync.Once.Do</code></a> 方法传入不同的函数只会执行第一次调传入的函数；</li>
</ul>
<h5 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h5><p>Go 语言标准库中还包含条件变量 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a>，它可以让一组的 Goroutine <strong>都在满足特定条件时被唤醒</strong>。每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 结构体在初始化时都需要传入一个互斥锁，我们可以通过下面的例子了解它的使用方法：</p>
<p><strong>声明</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock := new(sync.Mutex)</span><br><span class="line">cond := sync.NewCond(lock)</span><br></pre></td></tr></table></figure>

<p>也可以写成一行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond := sync.NewCond(new(sync.Mutex))</span><br></pre></td></tr></table></figure>

<p><strong>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cond.L.Lock()</span><br><span class="line">cond.L.Unlock()</span><br><span class="line">cond.Wait()</span><br><span class="line">cond.Signal()</span><br><span class="line">cond.Broadcast()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note</p>
<ul>
<li><code>cond.L.Lock()</code>和<code>cond.L.Unlock()</code>：也可以使用<code>lock.Lock()</code>和<code>lock.Unlock()</code>，完全一样，因为是指针转递</li>
<li><code>cond.Wait()</code>：Unlock()-&gt;*<strong>阻塞等待通知(即等待Signal()或Broadcast()的通知)-&gt;收到通知*</strong>-&gt;Lock()</li>
<li><code>cond.Signal()</code>：通知一个Wait()了的，若没有Wait()，也不会报错。<strong>Signal()通知的顺序是根据原来加入通知列表(Wait())的先入先出</strong></li>
<li><code>cond.Broadcast()</code>: 通知所有Wait()了的，若没有Wait()，也不会报错</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> listen(c)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(ch, os.Interrupt)</span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	atomic.StoreInt64(&amp;status, <span class="number">1</span>)</span><br><span class="line">	c.Broadcast()</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	<span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123;</span><br><span class="line">		c.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;listen&quot;</span>)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">listen</span><br><span class="line">...</span><br><span class="line">listen</span><br></pre></td></tr></table></figure>

<p>上述代码同时运行了 11 个 Goroutine，这 11 个 Goroutine 分别做了不同事情：</p>
<ul>
<li>10 个 Goroutine 通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Wait"><code>sync.Cond.Wait</code></a> 等待特定条件的满足；</li>
<li>1 个 Goroutine 会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 唤醒所有陷入等待的 Goroutine；</li>
</ul>
<p>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 方法后，上述代码会打印出 10 次 “listen” 并结束调用。</p>
<h5 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight"></a>SingleFlight</h5><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 是 Go 语言扩展包中提供了另一种同步原语，它能够在一个服务中抑制对下游的多次重复请求。一个比较常见的使用场景是：我们在使用 Redis 对数据库中的数据进行缓存，发生缓存击穿时，大量的流量都会打到数据库上进而影响服务的尾延时。</p>
<p><img src="/./../images/golang-query-without-single-flight.png" alt="golang-query-without-single-flight"></p>
<p><strong>图 6-12 Redis 缓存击穿问题</strong></p>
<p>但是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 能有效地解决这个问题，它能够限制对同一个键值对的多次重复请求，减少对下游的瞬时流量。</p>
<p><img src="/./../images/golang-extension-single-flight.png" alt="golang-extension-single-flight"></p>
<p><strong>图 6-13 缓解缓存击穿问题</strong></p>
<p>在资源的获取非常昂贵时（例如：访问缓存、数据库），就很适合使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 优化服务。我们来了解一下它的使用方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    requestGroup singleflight.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span></span> handleRequest(ctx context.Context, request Request) (Response, <span class="type">error</span>) &#123;</span><br><span class="line">    v, err, _ := requestGroup.Do(request.Hash(), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">        rows, err := <span class="comment">// select * from tables</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response&#123;</span><br><span class="line">        rows: rows,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为请求的哈希在业务上一般表示相同的请求，所以上述代码使用它作为请求的键。当然，我们也可以选择其他的字段作为 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.Do"><code>golang/sync/singleflight.Group.Do</code></a> 方法的第一个参数减少重复的请</p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Go 语言中最常见的、也是经常被人提及的设计模式就是：不要通过共享内存的方式进行通信，而是应该通过通信</p>
<p>的方式共享内存。在很多主流的编程语言中，多个线程传递数据的方式一般都是共享内存，为了解决线程竞争，我</p>
<p>们需要限制同一时间能够读写这些变量的线程数量，然而这与 Go 语言鼓励的设计并不相同。</p>
<p>虽然我们在 Go 语言中也能使用共享内存加互斥锁进行通信，但是 Go 语言提供了一种不同的并发模型，即通信顺</p>
<p>序进程（Communicating sequential processes，CSP）<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:1">1</a>。Goroutine 和 Channel 分别对应 CSP 中的实体和传</p>
<p>递信息的媒介，Goroutine 之间会通过 Channel 传递数据</p>
<p><strong>向channel发送数据</strong></p>
<p>我们在这里可以简单梳理和总结一下使用 <code>ch &lt;- i</code> 表达式向 Channel 发送数据时遇到的几种情况：</p>
<ol>
<li>如果当前 Channel 的 <code>recvq</code> 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前 Goroutine 并将其设置成下一个运行的 Goroutine；</li>
<li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 <code>sendx</code> 所在的位置上；</li>
<li>如果不满足上面的两种情况，会创建一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 结构并将其加入 Channel 的 <code>sendq</code> 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</li>
</ol>
<p>发送数据的过程中包含几个会触发 Goroutine 调度的时机：</p>
<ol>
<li>发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 <code>runnext</code> 属性，但是并不会立刻触发调度；</li>
<li>发送数据时并没有找到接收方并且缓冲区已经满了，这时会将自己加入 Channel 的 <code>sendq</code> 队列并调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.goparkunlock"><code>runtime.goparkunlock</code></a> 触发 Goroutine 的调度让出处理器的使用权；</li>
</ol>
<p><strong>接收channel数据</strong></p>
<p>我们梳理一下从 Channel 中接收数据时可能会发生的五种情况：</p>
<ol>
<li>如果 Channel 为空，那么会直接调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.gopark"><code>runtime.gopark</code></a> 挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.chanrecv"><code>runtime.chanrecv</code></a> 会直接返回；</li>
<li>如果 Channel 的 <code>sendq</code> 队列中存在挂起的 Goroutine，会将 <code>recvx</code> 索引所在的数据拷贝到接收变量所在的内存空间上并将 <code>sendq</code> 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据，那么直接读取 <code>recvx</code> 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 结构加入 <code>recvq</code> 队列并陷入休眠等待调度器的唤醒；</li>
</ol>
<p>我们总结一下从 Channel 接收数据时，会触发 Goroutine 调度的两个时机：</p>
<ol>
<li>当 Channel 为空时；</li>
<li>当缓冲区中不存在数据并且也不存在数据的发送者时；</li>
</ol>
<p><strong>关闭channel</strong></p>
<p>close方法</p>
<h4 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a><strong>Goroutine</strong></h4><p>历程</p>
<ul>
<li><p>单线程调度器 ·0.x</p>
<ul>
<li>只包含 40 多行代码；</li>
<li>程序中只能存在一个活跃线程，由 G-M 模型组成；</li>
</ul>
</li>
<li><p>多线程调度器 ·1.0</p>
<ul>
<li>允许运行多线程的程序；</li>
<li>全局锁导致竞争严重；</li>
</ul>
</li>
<li><p>任务窃取调度器 ·1.1</p>
<ul>
<li>引入了处理器 P，构成了目前的 <strong>G-M-P</strong> 模型；</li>
<li>在处理器 P 的基础上实现了基于<strong>工作窃取</strong>的调度器；</li>
<li>在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；</li>
<li>时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；</li>
</ul>
</li>
<li><p>抢占式调度器 ·1.2</p>
<p>~ 至今</p>
<ul>
<li>基于协作的抢占式调度器 - 1.2 ~ 1.13<ul>
<li>通过编译器在函数调用时插入<strong>抢占检查</strong>指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；</li>
<li>Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；</li>
</ul>
</li>
<li>基于信号的抢占式调度器 - 1.14 ~ 至今<ul>
<li>实现<strong>基于信号的真抢占式调度</strong>；</li>
<li>垃圾回收在扫描栈时会触发抢占调度；</li>
<li>抢占的时间点不够多，还不能覆盖全部的边缘情况；</li>
</ul>
</li>
</ul>
</li>
<li><p>非均匀存储访问调度器 · 提案</p>
<ul>
<li>对运行时的各种资源进行分区；</li>
<li>实现非常复杂，到今天还没有提上日程；</li>
</ul>
</li>
</ul>
<p>Go 语言在并发编程方面有强大的能力，这离不开语言层面对并发编程的支持</p>
<p>谈到 Go 语言调度器，我们绕不开的是操作系统、进程与线程这些概念，线程是操作系统调度时的最基本单元，而 <strong>Linux 在调度器并不区分进程和线程的调度</strong>，它们在不同操作系统上也有不同的实现，但是在大多数的实现中线程都属于进程：</p>
<p>在默认情况下，一个四核机器会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.m"><code>runtime.m</code></a> 结构体。</p>
<p>在大多数情况下，我们都会使用 Go 的默认设置，也就是线程数等于 CPU 数，默认的设置不会频繁触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少很多额外开销。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	sched.lastpoll = <span class="type">uint64</span>(nanotime())</span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调度器初始函数执行的过程中会将 <code>maxmcount</code> 设置成 10000，这也就是一个 Go 语言程序能够创建的最大线程数，虽然最多可以创建 10000 个线程，但是可以同时运行的线程还是由 <code>GOMAXPROCS</code> 变量控制。</p>
<p><strong>后续需要重新研究</strong></p>
<p>调度器的设计策略<br>复用线程：避免频繁的创建、销毁线程，而是对线程的复用。</p>
<p>1）work stealing 机制</p>
<p> 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。</p>
<p>2）hand off 机制</p>
<p> 当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。<br>转自链接：<a target="_blank" rel="noopener" href="https://learnku.com/articles/41728">https://learnku.com/articles/41728</a></p>
<p><img src="/./../images/gmp" alt="18-go-func调度周期.jpeg"></p>
<p>G1 本地队列 G5、G6 已经被其他 M 偷走并运行完成，当前 M1 和 M2 分别在运行 G2 和 G8，M3 和 M4 没有 goroutine 可以运行，M3 和 M4 处于自旋状态，它们不断寻找 goroutine。</p>
<p><img src="/./../images/%E8%87%AA%E6%97%8B%E7%BA%BF%E7%A8%8B" alt="34-gmp场景9.png"></p>
<p>为什么要让 m3 和 m4 自旋，自旋本质是在运行，线程在运行却没有执行 G，就变成了浪费 CPU. 为什么不销毁现场，来节约 CPU 资源。因为创建和销毁 CPU 也会浪费时间，我们希望当有新 goroutine 创建时，立刻能有 M 运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费 CPU，所以系统中最多有 GOMAXPROCS 个自旋的线程 (当前例子中的 GOMAXPROCS&#x3D;4，所以一共 4 个 P)，多余的没事做线程会让他们休眠。</p>
<p>P：processor，处理器，调度G到M上，其维护了一个队列，存储了所有需要它来调度的G。</p>
<p>在程序启动时会根据GOMAXPROCS配置的个数创建对应个数的P。</p>
<p><strong>注意：GOMAXPROCS 在容器中 会获取宿主机的核数 需要提前设置好 线程过多，会增加上线文切换的负担，白白浪费CPU。</strong></p>
<hr>
<h5 id="可视化-GMP-编程"><a href="#可视化-GMP-编程" class="headerlink" title="可视化 GMP 编程"></a>可视化 GMP 编程</h5><p><strong>go tool trace</strong></p>
<h4 id="网络轮询器"><a href="#网络轮询器" class="headerlink" title="网络轮询器"></a>网络轮询器</h4><h4 id="IO密集型与CPU密集型"><a href="#IO密集型与CPU密集型" class="headerlink" title="IO密集型与CPU密集型"></a>IO密集型与CPU密集型</h4><p>在今天，大部分的服务都是 I&#x2F;O 密集型的，应用程序会花费大量时间等待 I&#x2F;O 操作的完成。网络轮询器是 Go 语言运行时用来处理 I&#x2F;O 操作的关键组件，它使用了操作系统提供的 I&#x2F;O 多路复用机制增强程序的并发处理能力。本节会深入分析 Go 语言网络轮询器的设计与实现原理。</p>
<p>IO密集型和CPU密集型</p>
<ol>
<li>一个计算为主的应用程序（CPU密集型程序），多线程或多进程跑的时候，可以充分利用起所有的 CPU 核心数，比如说16核的CPU ，开16个线程的时候，可以同时跑16个线程的运算任务，此时是最大效率。但是如果线程数&#x2F;进程数远远超出 CPU 核心数量，反而会使得任务效率下降，因为<strong>频繁的切换线程或进程</strong>也是要消耗时间的。因此对于 CPU 密集型的任务来说，线程数&#x2F;进程数等于 CPU 数是最好的了。</li>
<li>如果是一个磁盘或网络为主的应用程序（IO密集型程序），一个线程处在 IO 等待的时候，另一个线程还可以在 CPU 里面跑，有时候 CPU 闲着没事干，所有的线程都在等着 IO，这时候他们就是同时的了，而单线程的话，此时还是在一个一个等待的。我们都知道IO的速度比起 CPU 来是很慢的。此时线程数可以是CPU核心数的数倍（视情况而定）。</li>
</ol>
<p><strong>CPU密集型举例：</strong></p>
<p>一个方法内部的逻辑，主要是需要序列化反序列化、加密解密、向量计算、大量循环判断和加减乘除运算，这些都是典型的CPU密集型场景。（Jvm垃圾回收器也是）</p>
<p>也可以说，大量用到了计算机的CPU硬件资源的业务逻辑，就是CPU密集型场景。还可以说，除了IO以外的，都是CPU密集型。</p>
<p><strong>IO密集型举例:</strong></p>
<p>数据库(可扩展) 缓存的读取RPC http 读取本地文件</p>
<p><strong>线程和CPU核心的关系？</strong></p>
<p>一个cpu核心 运行多个线程 会造成线程的切换</p>
<p><strong>需要多少线程？</strong>值得注意的是，线程不是越多越好。如果你的线程是不涉及任何I&#x2F;O、没有任何同步互斥之类的纯计算类型，那么每个核心一个线程通常是最佳选择。但通常来说，线程都需要一定的I&#x2F;O，可能需要一定的同步互斥，那么这时<strong>适当</strong>增加线程可能会提高性能，但当线程数量到达一个临界值后性能开始下降，这时线程间切换的开销将显著增加。这里之所以用适当这个词，是因为这很难去量化，<strong>只能用你实际的程序根据真正的场景进行测试才能得到这个值</strong>。</p>
<p>从上述IO和CPU三个角度的描述来看，我们也可以看出为什么CPU密集型的线程数要相对小很多（线程核数的量级），为什么IO密集型可以远大于核数。就是因为：</p>
<blockquote>
<p><strong>CPU密集型已经在不断地计算了</strong>，再开更多的线程也是得等CPU空闲出来，没意义，不会算得更快了；<br>而IO密集型是大量的再等待，CPU是空闲的，开启更多的线程可以让并发的请求更多，从而降低对外接口（方法）耗时，提升吞吐量。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lz710117239/article/details/123610632?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-2-123610632-blog-84997053.pc_relevant_vip_default&spm=1001.2101.3001.4242.2&utm_relevant_index=5">磁盘IO-为什么说IO密集型很少消耗CPU资源？_lz710117239的博客-CSDN博客_io操作占用cpu资源吗</a></p>
<p>用户空间 到 内核空间的拷贝是 cpu来执行</p>
<p>内核空间 到 硬盘 网络  是DMA执行</p>
<p>DMA 速度 相对于CPU存取速度极慢</p>
<p>导致 对于IO密集型程序 只有开始阶段会用到cpu拷贝 后面大部分时间CPU都在等待DMA执行，</p>
<p>此时优化可以用多线程 让多线程赶快处理下一个程序 而不用等待IO阻塞</p>
<p>若是CPU密集型的程序  单核多线程由于切换损耗 时间反而大于 顺序执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU计算文件地址 ==&gt; 委派DMA读取文件 ==&gt; DMA接管总线 ==&gt; CPU的A进程阻塞，挂起 ==&gt; CPU切换到B进程 ==&gt; DMA读完文件后通知CPU（一个中断异常） ==&gt; CPU切换回A进程操作文件</span><br></pre></td></tr></table></figure>

<p><strong>提问 数据库读写 是IO密集型吗  过程是怎么样的？？</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37989267/article/details/111041650">I&#x2F;O操作为什么不需要cpu_hllyzms的博客-CSDN博客_io操作需要cpu吗</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ludongguoa/p/15358504.html">CPU 核数与线程数有什么关系？ - ludongguoa - 博客园 (cnblogs.com)</a></p>
<p><strong>1.单独的地址空间</strong></p>
<p>根据大多书上的理论知识，目前我们应该很清楚，进程就是比线程多了一些东西，而最重要的应该是多了自己的虚拟地址空间。</p>
<p>线程拥有的资源很有限，只有个栈，然后在上面建立中断栈帧，运行必要的上下文等，也就是通常书上所说的寄存器资源。而进程拥有整个虚拟地址空间，整整 4 GB，它能在上面建立的东西可就太多了，堆栈，数据代码段等等，甚至还包括了线程所拥有的资源，这也就是为什么说线程要依赖于进程存在的原因。</p>
<p>所以可以说进程和线程最主要的区别就是有没有自己的地址空间，进程的其他特有的机制都是建立在地址空间之上的，而有没有地址空间就是有没有自己的页表，那么进程的task_struct可以如下定义：</p>
<p><img src="/./../images/%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%9B%E7%A8%8B_b.jpg" alt="img"></p>
<p>前面说过，进程依据线程实现，所以进程线程用的是同一个任务结构体，只是进程的pgdir有实际的值，而线程的pgdir设为NULL。</p>
<p><strong>2.特权级3用户态下工作</strong></p>
<p>进程的另一特点就是运行在 3 特权级，进程的创建在内核态下实现，如果调度的是进程，需要从内核态返回用户态，高特权级转成低特权级。而CPU一般不会允许从高特权级转回低特权级，只有一种情况例外，中断返回。</p>
<p>线程运行是模仿函数调用然后返回执行的，而这里我们进入 3 特权级则是模仿中断然后返回到 3 特权级，实有异曲同工之妙。关于中断栈帧的结构体线程那一块已经定义，这里不再赘述，直接看进程的创建。</p>
<hr>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>内存管理一般包含三个不同的组件，分别是用户程序（Mutator）、分配器（Allocator）和收集器（Collector）<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:1">1</a>，当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。</p>
<h5 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h5><h5 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a><strong>内存分配器</strong></h5><p>1.线性分配器</p>
<p>线性分配器只需再内存中维护一个指向内存特定位置得指针，用户程序向分配器申请内存，分配器只需要检查剩余内存，返回分配内存并修改指针位置</p>
<p>有较快得执行速度 和 较低得实现复杂度，<strong>但是线性分配器无法在内存被释放时重用内存。</strong></p>
<p>2.空闲链表分配器</p>
<p>可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表：</p>
<p>分配内存需要遍历链表 所以时间复杂度是On</p>
<p>Go语言得内存分配策略和 <code>隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块 </code> 有些相同</p>
<p>它会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，它会在找到满足条件的空闲内存块并返回</p>
<p>这样可以减少遍历次数 提高了内存分配的效率</p>
<h5 id="分级分配机制"><a href="#分级分配机制" class="headerlink" title="分级分配机制"></a>分级分配机制</h5><p>Go语言的内存分配器，运行时根据对象的大小将对象分成微对象、小对象和大对象三种：</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">微对象</td>
<td align="center"><code>(0, 16B)</code></td>
</tr>
<tr>
<td align="center">小对象</td>
<td align="center"><code>[16B, 32KB]</code></td>
</tr>
<tr>
<td align="center">大对象</td>
<td align="center"><code>(32KB, +∞)</code></td>
</tr>
</tbody></table>
<p>因为程序中的绝大多数对象的大小都在 32KB 以下，而申请的内存大小影响 Go 语言运行时分配内存的过程和开</p>
<p>销，<strong>所以分别处理大对象和小对象有利于提高内存分配器的性能</strong></p>
<p><strong>多级缓存</strong></p>
<p>内存分配器不仅会区别对待大小不同的对象，<strong>还会将内存分成不同的级别分别管理</strong>，TCMalloc 和 Go 运行时分配器都会引入<strong>线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）</strong>三个组件分级管理内存。</p>
<p><img src="/./../images/multi-level-cache.png" alt="multi-level-cache"></p>
<p>线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要</p>
<p>使用互斥锁来保护内存，<strong>这能够减少锁竞争带来的性能损耗</strong>。当线程缓存不能满足需求时，运行时会使用中心缓存</p>
<p>作为补充解决小对象的内存分配，在遇到 32KB 以上的对象时，内存分配器会选择页堆直接分配大内存。</p>
<p><strong>这种多层级的内存分配设计与计算机操作系统中的多级缓存有些类似</strong>，因为多数的对象都是小对象，我们可以通过</p>
<p>线程缓存和中心缓存提供足够的内存空间，发现资源不足时从上一级组件中获取更多的内存资源。</p>
<h5 id="虚拟内存布局"><a href="#虚拟内存布局" class="headerlink" title="虚拟内存布局"></a>虚拟内存布局</h5><p>在 Go 语言 1.10 以前的版本，堆区的内存空间都是连续的；但是在 1.11 版本，Go 团队使用稀疏的堆内存空间替代了连续的内存，解决了连续内存带来的限制以及在特殊场景下可能出现的问题。</p>
<p><strong>1.线性内存</strong></p>
<p>Go 语言程序的 1.10 版本在启动时会初始化整片虚拟内存区域，如下所示的三个区域 <code>spans</code>、<code>bitmap</code> 和 <code>arena</code> 分别预留了 512MB、16GB 以及 512GB 的内存空间，这些内存并不是真正存在的物理内存，而是虚拟内存：</p>
<p><img src="/./../images/heap-before-go-1-10.png" alt="heap-before-go-1-10"></p>
<ul>
<li><code>spans</code> 区域存储了指向内存管理单元 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 的指针，每个内存单元会管理几页的内存空间，每页大小为 8KB；</li>
<li><code>bitmap</code> 用于标识 <code>arena</code> 区域中的那些地址保存了对象，位图中的每个字节都会表示堆区中的 32 字节是否空闲；</li>
<li><code>arena</code> 区域是真正的堆区，运行时会将 8KB 看做一页，这些内存页中存储了所有在堆上初始化的对象；</li>
</ul>
<p>对于任意一个地址，我们都可以根据 <code>arena</code> 的基地址计算该地址所在的页数并通过 <code>spans</code> 数组获得管理该片内存的管理单元 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>，<code>spans</code> 数组中多个连续的位置可能对应同一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 结构。</p>
<p><strong>不足之处：</strong></p>
<p><strong>2.稀疏内存</strong></p>
<p>稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:5">5</a>，还能解决 C 和 Go 混合使用时的地址空间冲突问题<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:6">6</a>。不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂：</p>
<p><img src="/./../images/-heap-after-go-1-11.png" alt="heap-after-go-1-11"></p>
<p>运行时使用二维的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.heapArena"><code>runtime.heapArena</code></a> 数组管理所有的内存，每个单元都会管理 64MB 的内存空间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">	bitmap       [heapArenaBitmapBytes]<span class="type">byte</span></span><br><span class="line">	spans        [pagesPerArena]*mspan</span><br><span class="line">	pageInUse    [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">	pageMarks    [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">	pageSpecials [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">	checkmarks   *checkmarksMap</span><br><span class="line">	zeroedBase   <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构体中的 <code>bitmap</code> 和 <code>spans</code> 与线性内存中的 <code>bitmap</code> 和 <code>spans</code> 区域一一对应，<code>zeroedBase</code> 字段指向了该结构体管理的内存的基地址。<strong>上述设计将原有的连续大内存切分成稀疏的小内存，而用于管理这些内存的元信息也被切成了小块</strong>。</p>
<h5 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a><strong>地址空间</strong></h5><p>因为所有的内存最终都是要从操作系统中申请的，所以 Go 语言的运行时构建了操作系统的内存管理抽象层，该抽象层将运行时管理的地址空间分成以下四种状态<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:8">8</a>：</p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>None</code></td>
<td align="center">内存没有被保留或者映射，是地址空间的默认状态</td>
</tr>
<tr>
<td align="center"><code>Reserved</code></td>
<td align="center">运行时持有该地址空间，但是访问该内存会导致错误</td>
</tr>
<tr>
<td align="center"><code>Prepared</code></td>
<td align="center">内存被保留，一般没有对应的物理内存访问该片内存的行为是未定义的可以快速转换到 <code>Ready</code> 状态</td>
</tr>
<tr>
<td align="center"><code>Ready</code></td>
<td align="center">可以被安全访问</td>
</tr>
</tbody></table>
<hr>
<h5 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h5><p><img src="/./../images/go-memory-layout.png" alt="go-memory-layout"></p>
<p><strong>内存管理单元</strong></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 是 Go 语言内存管理的基本单元，该结构体中包含 <code>next</code> 和 <code>prev</code> 两个字段，它们分别指向了前一个和后一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>：</p>
<p>每个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 都管理 <code>npages</code> 个大小为 8KB 的页，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍，该结构体会使用下面这些字段来管理内存页的分配和回收：</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 会以两种不同的视角看待管理的内存，当结构体管理的内存不足时，运行时会以页为单位向堆申请内存：</p>
<p>当用户程序或者线程向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 申请内存时，它会使用 <code>allocCache</code> 字段以对象为单位在管理的内存中快速查找待分配的空间：</p>
<p><strong>线程缓存</strong></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有 68 * 2 个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>，这些内存管理单元都存储在结构体的 <code>alloc</code> 字段中：</p>
<p><img src="/./../images/2020-02-29-15829868066512-mcache-and-mspans.png" alt="mcache-and-mspans"></p>
<p>线程缓存在刚刚被初始化时是不包含 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 的，只有当用户程序申请内存时才会从上一级组件获取新的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 满足内存分配的需求。</p>
<p><strong>中心缓存</strong></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcentral"><code>runtime.mcentral</code></a> 是内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的内存管理单元需要使用互斥锁：</p>
<p><strong>每个中心缓存都会管理某个跨度类的内存管理单元，</strong>它会同时持有两个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.spanSet"><code>runtime.spanSet</code></a>，分别存储包含空闲对象和不包含空闲对象的内存管理单元。</p>
<p><strong>页堆</strong></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> 是内存分配的核心结构体，Go 语言程序会将其作为全局变量存储，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 <code>central</code>，另一个是管理堆区内存区域的 <code>arenas</code> 以及相关字段。</p>
<p>每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.heapArena"><code>runtime.heapArena</code></a> 都会管理 64MB 的内存空间。</p>
<p>流程：xxxx</p>
<p><strong>内存分配</strong></p>
<ul>
<li>微对象 <code>(0, 16B)</code> — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</li>
<li>小对象 <code>[16B, 32KB]</code> — 依次尝试使用线程缓存、中心缓存和堆分配内存；</li>
<li>大对象 <code>(32KB, +∞)</code> — 直接在堆上分配内存；</li>
</ul>
<p>小结：</p>
<p>内存分配是 Go 语言运行时内存管理的核心逻辑，运行时的内存分配器使用<strong>类似 TCMalloc 的分配策略将对象根据大小分类</strong>，并设计多层级的组件提高内存分配器的性能</p>
<p><strong>微对象</strong></p>
<p>Go 语言运行时将小于 16 字节的对象划分为微对象，它会使用<strong>线程缓存上的微分配器</strong>提高微对象分配的性能，我</p>
<p>们主要使用它来分配较小的字符串以及逃逸的临时变量。<strong>微分配器可以将多个较小的内存分配请求合入同一个内存</strong></p>
<p><strong>块中</strong>，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收。</p>
<p>若微分配器已经在 16 字节的内存块中分配了 12 字节的对象，如果下一个待分配的对象小于 4 字节，它会直接使</p>
<p>用上述内存块的剩余部分，减少内存碎片，<strong>不过该内存块只有所有对象都被标记为垃圾时才会回收。</strong></p>
<p>当内存块中不包含空闲的内存时，下面的这段代码会先从线程缓存找到跨度类对应的内存管理单元 </p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.nextFreeFast"><code>runtime.nextFreeFast</code></a> 获取空闲的内存；当不存在空闲内存时，我们会调用 </p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache.nextFree"><code>runtime.mcache.nextFree</code></a> 从中心缓存或者页堆中获取可分配的内存块</p>
<hr>
<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p>相信很多人对垃圾收集器的印象都是暂停程序（Stop the world，STW），随着用户程序申请越来越多的内存，系统中的垃圾也逐渐增多；当程序的内存占用达到一定阈值时，整个应用程序就会全部暂停，垃圾收集器会扫描已经分配的所有对象并回收不再使用的内存空间，当这个过程结束后，用户程序才可以继续执行，Go 语言在早期也使用这种策略实现垃圾收集，但是今天的实现已经复杂了很多。</p>
<p>1.标记清除</p>
<p>标记清除（Mark-Sweep）算法是最常见的垃圾收集算法，标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p>
<ol>
<li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li>
<li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表；</li>
</ol>
<p>2.三色抽象</p>
<p>为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:4">4</a>：</p>
<ul>
<li>白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；</li>
<li>黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li>
<li>灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</li>
</ul>
<p>在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。</p>
<p>三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：</p>
<ol>
<li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色；</li>
<li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li>
<li>重复上述两个步骤直到对象图中不存在灰色对象；</li>
</ol>
<p>三色错误的回收，需要用到屏障技术。</p>
<p>内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:6">6</a></p>
<p>Go 语言中使用的两种写屏障技术，分别是 Dijkstra 提出的插入写屏障<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:8">8</a>和 Yuasa 提出的删除写屏障<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:9">9</a>，这里会分析它们如何保证三色不变性和垃圾收集器的正确性。</p>
<p>申请内存：</p>
<ol>
<li>当前线程的内存管理单元中不存在空闲空间时，创建微对象和小对象需要调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache.nextFree"><code>runtime.mcache.nextFree</code></a> 从中心缓存或者页堆中获取新的管理单元，在这时就可能触发垃圾收集；</li>
<li>当用户程序申请分配 32KB 以上的大对象时，一定会构建 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.gcTrigger"><code>runtime.gcTrigger</code></a> 结构体尝试触发垃圾收集；</li>
</ol>
<hr>
<h5 id="栈内存管理"><a href="#栈内存管理" class="headerlink" title="栈内存管理"></a>栈内存管理</h5><p><strong>分段栈</strong></p>
<p>分段栈是 Go 语言在 v1.3 版本之前的实现，所有 Goroutine 在初始化时都会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackalloc:go1.2"><code>runtime.stackalloc:go1.2</code></a> 分配一块固定大小的内存空间，这块内存的大小由 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.StackMin:go1.2"><code>runtime.StackMin:go1.2</code></a> 表示，在 v1.2 版本中为 8KB：</p>
<p>如果通过该方法申请的内存大小为固定的 8KB 或者满足其他的条件，运行时会在全局的栈缓存链表中找到空闲的内存块并作为新 Goroutine 的栈空间返回；在其余情况下，栈内存空间会从堆上申请一块合适的内存。</p>
<p>分段栈机制虽然能够按需为当前 Goroutine 分配内存并且及时减少内存的占用，但是它也存在两个比较大的问题：</p>
<ol>
<li>如果当前 Goroutine 的栈几乎充满，那么任意的函数调用都会触发栈扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）；</li>
<li>一旦 Goroutine 使用的内存<strong>越过</strong>了分段栈的扩缩容阈值，运行时会触发栈的扩容和缩容，带来额外的工作量；</li>
</ol>
<p><strong>连续栈</strong></p>
<p>连续栈可以解决分段栈中存在的两个问题，其核心原理是每当程序的栈空间不足时，初始化一片更大的栈空间并将原栈中的所有值都迁移到新栈中，新的局部变量或者函数调用就有充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：</p>
<ol>
<li>在内存空间中分配更大的栈内存空间；</li>
<li>将旧栈中的所有内容复制到新栈中；</li>
<li><strong>将指向旧栈对应变量的指针重新指向新栈</strong>；</li>
<li>销毁并回收旧栈的内存空间；</li>
</ol>
<p>因为需要拷贝变量和调整指针，连续栈增加了栈扩容时的额外开销，但是通过合理栈缩容机制就能避免热分裂带来的性能问题<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#fn:10">10</a>，在 GC 期间如果 Goroutine 使用了栈内存的四分之一，那就将其内存减少一半，这样在栈内存几乎充满时也只会扩容一次，不会因为函数调用频繁扩缩容</p>
<p>缺点</p>
<hr>
<h4 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h4><p>静态库和动态库的优缺点也比较明显；只依赖静态库并且通过静态链接生成的二进制文件因为<strong>包含了全部的依赖，所以能够独立执行，但是编译的结果也比较大</strong>；（Go 默认的方式 直接生产可执行文件）</p>
<p>而动态库可以在多个可执行文件之间共享，可以减少内存的占用，其链接的过程往往也都是在装载或者运行期间触发的，所以可以包含一些可以热插拔的模块并降低内存的占用。</p>
<p>使用静态链接编译二进制文件在部署上有非常明显的优势，最终的编译产物也可以直接运行在大多数的机器上，静</p>
<p>态链接带来的部署优势远比更低的内存占用显得重要，所以很多编程语言包括 Go 都将静态链接作为默认的链接方</p>
<p>式。</p>
<hr>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>在应用层协议中，最常见的两种解决方案是基于长度或者基于终结符（Delimiter）。HTTP 协议其实同时实现了上述两种方案，在多数情况下 HTTP 协议都会在协议头中加入 <code>Content-Length</code> 表示负载的长度，消息的接收者解析到该协议头之后就可以确定当前 HTTP 请求&#x2F;响应结束的位置，分离不同的 HTTP 消息，下面就是一个使用 <code>Content-Length</code> 划分消息边界的例子：</p>
<p>不过 HTTP 协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 <code>Content-Length</code> 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界。</p>
<hr>
<h3 id="需要关注的知识点"><a href="#需要关注的知识点" class="headerlink" title="需要关注的知识点"></a>需要关注的知识点</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7090884238588772383">Golang 位运算实战用法 - 掘金 (juejin.cn)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 火焰图  需要 ctrl+c 停止程序</span><br><span class="line">go tool pprof --http=:8080 http://localhost:9909/debug/pprof/profile</span><br><span class="line"></span><br><span class="line"># 性能分析</span><br><span class="line">go tool pprof  http://localhost:9909/debug/pprof/profile?seconds=30</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/391656415">Go性能分析工具pprof - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2090597">让你最快上手 go 的 pprof 性能分析大杀器 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019222661#go">go - 实战Go内存泄露_个人文章 - SegmentFault 思否</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45959147">谁占了该CPU核的30% - 一个较意外的Go性能问题 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138777955">Golang 反射性能优化 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/72446db4e43e">golang笔记——深入了解netpoller - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/272891398">一文搞懂select、poll和epoll区别 - 知乎 (zhihu.com)</a></p>
<p>rune类型</p>
<p><code>rune</code> 是类型 <code>int32</code> 的别名，在所有方面都等价于它</p>
<p>1.统计带其余字体得字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换成 rune 数组后统计字符串长度</span></span><br><span class="line"><span class="comment">// 英文字符占用 1 字节，中文字符占用 3 字节</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(<span class="string">&quot;Go语言编程&quot;</span>)))  <span class="comment">// 输出：6</span></span><br></pre></td></tr></table></figure>

<p>2.截取带中文字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;Go语言编程&quot;</span></span><br><span class="line"><span class="comment">// 转成 rune 数组，需要几个字符，取几个字符</span></span><br><span class="line">fmt.Println(<span class="type">string</span>([]<span class="type">rune</span>(s)[:<span class="number">4</span>])) <span class="comment">// 输出：Go语言  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Go 语言把字符分 <code>byte</code> 和 <code>rune</code> 两种类型处理。<code>byte</code> 是类型 <code>unit8</code> 的别名，用于存放占 1 字节的 ASCII 字符，如英文字符，返回的是字符原始字节。<code>rune</code> 是类型 <code>int32</code> 的别名，用于存放多字节字符，如占 3 字节的中文字符，返回的是字符 Unicode 码点值。如下图所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;Go语言编程&quot;</span></span><br><span class="line"><span class="comment">// byte</span></span><br><span class="line">fmt.Println([]<span class="type">byte</span>(s)) <span class="comment">// 输出：[71 111 232 175 173 232 168 128 231 188 150 231 168 139]</span></span><br><span class="line"><span class="comment">// rune</span></span><br><span class="line">fmt.Println([]<span class="type">rune</span>(s)) <span class="comment">// 输出：[71 111 35821 35328 32534 31243]</span></span><br></pre></td></tr></table></figure>





<p>go 空接口的理解</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7055178269112401933">Go1.16逃逸分析原理剖析 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7140864963974791175">一文搞懂golang内存逃逸分析 - 掘金 (juejin.cn)</a></p>
<p>一面问我map实现原理</p>
<p>问我goroutinue调度</p>
<p>还问不同方法初始化切片的区别</p>
<p>for range 陷阱</p>
<p>a. 是否支持while循环，如何实现这种机制<br>b. 哪些<a href="">数据</a>类型只能用make来创建？<br>c. 两个数组长度不同，做类型比较会相同吗？<br><strong>d. slice和array区别？</strong><br>e. go里面如何实现set？</p>
<p>f. go如何实现类似于java当中的继承机制？<br>g. go实现面向对象的机制？怎么去复用一个接口的方法？<br>h. go里面的 _<br>i. 并发里面channel buf设置成0和不为0有啥区别？<br> ⅰ. 无缓存channel的使用场景？<br>j. goroutine创建的时候如果要传一个参数进去有什么要注意的点？<br> ⅰ. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/waken-captain/p/10496454.html">https://www.cnblogs.com/waken-captain/p/10496454.html</a><br>k. 写go单元<a href="">测试</a>的规范？<br>l. 单步调试？<br>m. 导入一个go的工程，有些依赖找不到，改怎么办？</p>
<p>a. <a target="_blank" rel="noopener" href="https://blog.csdn.net/Z_Y_D_/article/details/84646443">https://blog.csdn.net/Z_Y_D_/article/details/84646443</a><br>b. <a target="_blank" rel="noopener" href="https://blog.csdn.net/flyersboy/article/details/117266318">https://blog.csdn.net/flyersboy/article/details/117266318</a><br>c. <a target="_blank" rel="noopener" href="https://blog.csdn.net/u010983881/article/details/75097358">https://blog.csdn.net/u010983881/article/details/75097358</a><br>d. <a target="_blank" rel="noopener" href="https://kb.cnblogs.com/page/52050/">https://kb.cnblogs.com/page/52050/</a></p>
<ul>
<li>如何判定Slice是否是空的？（<strong>Slice判空</strong>）</li>
</ul>
<p><strong>绝对不能用 if slice &#x3D;&#x3D; nil 这样的方式</strong></p>
<p>因为可以创建<code>nil</code>的slice</p>
<ul>
<li>正确方法：<code>len(slice) == 0</code></li>
</ul>
<p><strong>空slice和nil slice的对比，深度理解为什么 slice &#x3D;&#x3D; nil 不可行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1 []int // nil slice</span><br><span class="line">s2 := []int&#123;&#125; // empty slice</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="内存逃逸"><a href="#内存逃逸" class="headerlink" title="内存逃逸"></a>内存逃逸</h4><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039843497">后端 - 简单聊聊内存逃逸 ｜ 剑指 offer - golang_个人文章 - SegmentFault 思否</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040450335">go - 详解Go语言中的内存逃逸_个人文章 - SegmentFault 思否</a></p>
<p><strong>内存逃逸危害</strong></p>
<p>堆是一块没有特定结构，也没有固定大小的内存区域，可以根据需要进行调整。全局变量，内存占用较大的局部变量，函数调用结束后不能立刻回收的局部变量都会存在堆里面。变量在堆上的分配和回收都比在栈上开销大的多。对于 go 这种带 GC 的语言来说，会增加 gc 压力，同时也容易造成内存碎片。</p>
<p>从”栈”上逃逸到”堆”上的现象就成为内存逃逸。</p>
<p>逃逸分析就是指程序在编译阶段根据代码中的数据流，对代码中哪些变量需要在栈中分配，哪些变量需要在堆上分配进行静态分析的方法。堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片，栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。所以逃逸分析更做到更好内存分配，提高程序的运行速度。</p>
<p><strong>内存逃逸分析</strong></p>
<p>build时添加<code>-gcflags=-m</code> 选项可分析内存逃逸情况,比如输出<code>./main.go:3:6: moved to heap: x</code> 表示局部变量x逃逸到了堆上。</p>
<p><strong>避免内存逃逸的办法</strong></p>
<ul>
<li>对于小型的数据，使用传值而不是传指针，避免内存逃逸。</li>
<li>避免使用长度不固定的slice切片，在编译期无法确定切片长度，只能将切片使用堆分配。</li>
<li>interface调用方法会发生内存逃逸，在热点代码片段，谨慎使用。</li>
</ul>
<h3 id="代码实操坑"><a href="#代码实操坑" class="headerlink" title="代码实操坑"></a>代码实操坑</h3><p>1.字符串不能通过下标得方式去修改</p>
<p>报错 <code>cannot assign to s[lenRes] (value of type byte)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	str unsafe.Pointer <span class="comment">// 指向一个byte类型的切片指针</span></span><br><span class="line">	<span class="built_in">len</span> <span class="type">int</span> <span class="comment">// 字符串的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正是因为底层是一个[]byte类型的切片，当我们使用下标的方式去修改值，这时候将一个字符内容赋值给byte类型，肯定是不允许的。但是我们可以通过下标的方式去访问对应的byte值。</p>
<p>所以字符串是无法被修改的，只能复制原字符串，在复制的版本上修改 </p>
<p>方法1：转换为[]byte()   （需要频繁批量修改 建议一次性都转为byte）</p>
<p>方法2：转换为[]rune() </p>
<p>方法3：新字符串代替原字符串的子字符串,用strings包中的strings.Replace()*</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">DSAD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/17/Go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/">http://example.com/2023/01/17/Go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Astrals</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a><a class="post-meta__tags" href="/tags/%E5%8E%9F%E7%90%86/">原理</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">读书记录</a></div><div class="post_share"><div class="social-share" data-image="/./../images/go%E5%90%89%E7%A5%A5%E7%89%A94.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="为什么会是虚拟内存?"><img class="cover" src="/./../images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">为什么会是虚拟内存?</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/09/linux%E5%86%85%E6%A0%B8%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" title="&lt;&lt;Linux内核设计与实现&gt;&gt;读书记录"><img class="cover" src="/./../images/Linux.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">&lt;&lt;Linux内核设计与实现&gt;&gt;读书记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="为什么会是虚拟内存?"><img class="cover" src="/./../images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-23</div><div class="title">为什么会是虚拟内存?</div></div></a></div><div><a href="/2019/01/13/STL/" title="STL知识汇总"><img class="cover" src="/./../images/C++.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-13</div><div class="title">STL知识汇总</div></div></a></div><div><a href="/2022/06/09/linux%E5%86%85%E6%A0%B8%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" title="&lt;&lt;Linux内核设计与实现&gt;&gt;读书记录"><img class="cover" src="/./../images/Linux.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-09</div><div class="title">&lt;&lt;Linux内核设计与实现&gt;&gt;读书记录</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">DSAD</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Astrals24/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">自己看,随缘更新,旨在记录一些大事情方便回忆,偶尔分享一些自己觉得不错的书籍笔记。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go"><span class="toc-number">1.</span> <span class="toc-text">深入理解Go</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">1.1.</span> <span class="toc-text">结构体内存对齐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">1.3.</span> <span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E5%92%8C%E6%89%A9%E5%AE%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">追加和扩容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.3.3.</span> <span class="toc-text">拷贝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">map哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99"><span class="toc-number">1.4.2.</span> <span class="toc-text">读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.3.</span> <span class="toc-text">访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">1.4.4.</span> <span class="toc-text">扩容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.4.5.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%96%91%E9%97%AE"><span class="toc-number">1.4.7.</span> <span class="toc-text">疑问</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.1.</span> <span class="toc-text">拼接问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.2.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.8.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-range"><span class="toc-number">1.9.</span> <span class="toc-text">for-range</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%B0%B8%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.9.1.</span> <span class="toc-text">循环永动机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for-range%E9%99%B7%E9%98%B1"><span class="toc-number">1.9.2.</span> <span class="toc-text">for range陷阱</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">1.10.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#defer"><span class="toc-number">1.11.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#panic-%E4%B8%8E-recover"><span class="toc-number">1.12.</span> <span class="toc-text">panic 与 recover</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#make%E5%92%8Cnew"><span class="toc-number">1.13.</span> <span class="toc-text">make和new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87Context"><span class="toc-number">1.14.</span> <span class="toc-text">上下文Context</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81"><span class="toc-number">1.15.</span> <span class="toc-text">同步原语与锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Mutex"><span class="toc-number">1.15.1.</span> <span class="toc-text">Mutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RWMutex"><span class="toc-number">1.15.2.</span> <span class="toc-text">RWMutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WaitGroup"><span class="toc-number">1.15.3.</span> <span class="toc-text">WaitGroup</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Cond"><span class="toc-number">1.15.4.</span> <span class="toc-text">Cond</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SingleFlight"><span class="toc-number">1.15.5.</span> <span class="toc-text">SingleFlight</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-number">1.16.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Goroutine"><span class="toc-number">1.17.</span> <span class="toc-text">Goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96-GMP-%E7%BC%96%E7%A8%8B"><span class="toc-number">1.17.1.</span> <span class="toc-text">可视化 GMP 编程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8"><span class="toc-number">1.18.</span> <span class="toc-text">网络轮询器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%B8%8ECPU%E5%AF%86%E9%9B%86%E5%9E%8B"><span class="toc-number">1.19.</span> <span class="toc-text">IO密集型与CPU密集型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.20.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-number">1.20.1.</span> <span class="toc-text">设计原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.20.2.</span> <span class="toc-text">内存分配器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%BA%A7%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">1.20.3.</span> <span class="toc-text">分级分配机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.20.4.</span> <span class="toc-text">虚拟内存布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.20.5.</span> <span class="toc-text">地址空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6"><span class="toc-number">1.20.6.</span> <span class="toc-text">内存管理组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.20.7.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.20.8.</span> <span class="toc-text">栈内存管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.21.</span> <span class="toc-text">插件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.22.</span> <span class="toc-text">HTTP协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">需要关注的知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8"><span class="toc-number">2.1.</span> <span class="toc-text">内存逃逸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%93%8D%E5%9D%91"><span class="toc-number">3.</span> <span class="toc-text">代码实操坑</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="为什么会是虚拟内存?"><img src="/./../images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="为什么会是虚拟内存?"/></a><div class="content"><a class="title" href="/2023/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="为什么会是虚拟内存?">为什么会是虚拟内存?</a><time datetime="2023-01-22T16:00:00.000Z" title="发表于 2023-01-23 00:00:00">2023-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/17/Go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" title="深入理解Go"><img src="/./../images/go%E5%90%89%E7%A5%A5%E7%89%A94.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解Go"/></a><div class="content"><a class="title" href="/2023/01/17/Go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" title="深入理解Go">深入理解Go</a><time datetime="2023-01-16T16:00:00.000Z" title="发表于 2023-01-17 00:00:00">2023-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/09/linux%E5%86%85%E6%A0%B8%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" title="&lt;&lt;Linux内核设计与实现&gt;&gt;读书记录"><img src="/./../images/Linux.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;&lt;Linux内核设计与实现&gt;&gt;读书记录"/></a><div class="content"><a class="title" href="/2022/06/09/linux%E5%86%85%E6%A0%B8%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" title="&lt;&lt;Linux内核设计与实现&gt;&gt;读书记录">&lt;&lt;Linux内核设计与实现&gt;&gt;读书记录</a><time datetime="2022-06-08T16:00:00.000Z" title="发表于 2022-06-09 00:00:00">2022-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/01/%E6%B7%B1%E5%85%A5%E5%88%A8%E6%9E%90Kubernetes%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/" title="&lt;&lt;深入刨析Kubernetes&gt;&gt;读书记录"><img src="/./../images/kubernetes.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;&lt;深入刨析Kubernetes&gt;&gt;读书记录"/></a><div class="content"><a class="title" href="/2021/11/01/%E6%B7%B1%E5%85%A5%E5%88%A8%E6%9E%90Kubernetes%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/" title="&lt;&lt;深入刨析Kubernetes&gt;&gt;读书记录">&lt;&lt;深入刨析Kubernetes&gt;&gt;读书记录</a><time datetime="2021-10-31T16:00:00.000Z" title="发表于 2021-11-01 00:00:00">2021-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/keepalived+MySQL%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8/" title="Keepalived+MySQL实现高可用"><img src="/./../images/Astral.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Keepalived+MySQL实现高可用"/></a><div class="content"><a class="title" href="/2021/10/17/keepalived+MySQL%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8/" title="Keepalived+MySQL实现高可用">Keepalived+MySQL实现高可用</a><time datetime="2021-10-16T16:00:00.000Z" title="发表于 2021-10-17 00:00:00">2021-10-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By DSAD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>